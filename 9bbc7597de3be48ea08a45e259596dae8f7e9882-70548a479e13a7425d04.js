"use strict";(self.webpackChunkaryumka_me=self.webpackChunkaryumka_me||[]).push([[4202],{1e3:function(n,a,s){s.r(a);var e=s(9128),t=s(9474);function p(n){const a=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",span:"span",blockquote:"blockquote",strong:"strong",img:"img",h3:"h3",ul:"ul",li:"li"},(0,e.R)(),n.components);return t.createElement(t.Fragment,null,t.createElement(a.h1,{id:"di는-왜-필요할까"},t.createElement(a.a,{href:"#di는-왜-필요할까"},"DI는 왜 필요할까")),"\n",t.createElement(a.h2,{id:"개요"},t.createElement(a.a,{href:"#개요"},"개요")),"\n",t.createElement(a.p,null,t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">DI</code>'}}),"는 의존관계 주입(Dependency Injection)의 줄임말으로 객체지향 디자인패턴 중 하나이다.\n객체지향 프로그램 내 객체들은 다양한 생명주기를 가지며 서로 상호작용하고 다양한 형태의 의존관계를 갖게 된다."),"\n",t.createElement(a.blockquote,null,"\n",t.createElement(a.p,null,t.createElement(a.strong,null,"Dependency?"),"\n의존관계 혹은 의존성. Dependency를 직역하면 의존성이기도 하고 흔히 이렇게 불리고 있지만 의존관계라는 표현이 더 의미전달에 맞다고 생각하여 (토비의 스프링 참조) 의존관계로 표현한다."),"\n"),"\n",t.createElement(a.p,null,"코드를 예시로 살펴보자. 아래와 같은 프로그램이 있을 때,"),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="java"><pre class="language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>\n\t<span class="token class-name">Toy</span> toy<span class="token punctuation">;</span>\n    <span class="token keyword">public</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token class-name">Toy</span> toy<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    \t<span class="token keyword">this</span><span class="token punctuation">.</span>toy <span class="token operator">=</span> toy<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">interface</span> <span class="token class-name">Toy</span> <span class="token punctuation">{</span>\n\t<span class="token comment">/*...*/</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">Doll</span> <span class="token keyword">implements</span> <span class="token class-name">Toy</span> <span class="token punctuation">{</span>\n\t<span class="token comment">/*...*/</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Dog</code>'}}),"는 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Toy</code>'}}),"에 의존관계를 갖고있다. 이제 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Doll</code>'}}),"객체를 받아 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Dog</code>'}}),"객체를 생성하려면 어떻게 해야 할까?"),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="java"><pre class="language-java"><code class="language-java"><span class="token class-name">Toy</span> doll <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Doll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token class-name">Dog</span> cuteDog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span>doll<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Toy</code>'}}),"객체를 직접 생성, ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Dog</code>'}}),"객체가 생성될 때 직접적으로 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Doll</code>'}}),"와 의존관계를 맺을수도 있고"),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="java"><pre class="language-java"><code class="language-java"><span class="token comment">/* 외부 모듈 Injector에 의해 의존관계 주입 */</span>\n<span class="token comment">/* Config에 Dog와 Doll의 의존관계가 미리 설정되어 있다고 가정한다.*/</span>\n<span class="token class-name">Injector</span> injector <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Injector</span><span class="token punctuation">(</span><span class="token class-name">Config</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token class-name">Dog</span> cuteDog <span class="token operator">=</span> injector<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Dog</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"외부모듈에 의해 미리 생성된 의존관계를 공급받아 객체를 생성하기도 한다. 후자와 같은 형태를 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">DI</code>'}})," 패턴이라고 한다."),"\n",t.createElement(a.p,null,"그림으로 나타내면 아래와 같다."),"\n",t.createElement(a.img,{src:"https://velog.velcdn.com/images/aryumka/post/7f996a48-7da4-4a94-acd1-336eae84403e/image.png",alt:""}),"\n","\n","\n",t.createElement(a.img,{src:"https://velog.velcdn.com/images/aryumka/post/0dbb415c-8d11-4398-bb95-7ffec7122e44/image.png",alt:""}),"\n",t.createElement(a.p,null,"의존관계 ",t.createElement(a.strong,null,"주입"),"이라는 말에서 알 수 있듯 DI 패턴에서는 객체 ",t.createElement(a.strong,null,"외부의 다른 객체 또는 모듈"),"이 객체 생성 및 의존관계 설정을 담당한다.\n",t.createElement(a.strong,null,"마치 블록을 조립할 때 블록이 아닌 조립하는 사람이 완성된 모양을 결정하는 것처럼 말이다.")),"\n",t.createElement(a.h2,{id:"dipdependency-inversion-principle-의존관계-역전-원칙"},t.createElement(a.a,{href:"#dipdependency-inversion-principle-의존관계-역전-원칙"},"DIP(Dependency Inversion Principle): 의존관계 역전 원칙")),"\n",t.createElement(a.p,null,"객체가 자신의 의존관계를 직접 설정하지 않도록 하는 이유가 뭘까?\n객체지향 원칙인 **",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">SOLID</code>'}}),"**를 살펴보자."),"\n",t.createElement(a.blockquote,null,"\n",t.createElement(a.p,null,t.createElement(a.strong,null,"S"),": 단일 책임 원칙 (Single responsibility principle) - 한 클래스는 하나의 책임만 가져야 한다.\n",t.createElement(a.strong,null,"O"),": 개방-폐쇄 원칙 (Open/closed principle) - “소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.”\n",t.createElement(a.strong,null,"L"),": 리스코프 치환 원칙 (Liskov substitution principle) - “프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.” 계약에 의한 설계를 참고하라.\n",t.createElement(a.strong,null,"I"),": 인터페이스 분리 원칙 (Interface segregation principle) - “특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.”\n",t.createElement(a.strong,null,"D"),": 의존관계 역전 원칙 (Dependency inversion principle) - 프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.”\n",t.createElement(a.a,{href:"https://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84)",rel:"nofollow noopener noreferrer"},"출처: 위키피디아")),"\n"),"\n",t.createElement(a.p,null,"이 중 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">의존관계 역전 원칙</code>'}}),"을 실행하기 위한 방법 중 하나가 DI 패턴이다."),"\n",t.createElement(a.p,null,"만약 위의 예시 코드에서 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Dog</code>'}}),"가 주입받는 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Toy</code>'}})," 객체가 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Doll</code>'}}),"이 아니라 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Bone</code>'}}),"객체로 바뀐다면 어떻게 될까? 직접 의존관계를 설정한 프로그램이라면 아마도 아래와 같이 구체적 코드를 변경해야 할 것이다."),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="java"><pre class="language-java"><code class="language-java"><span class="token class-name">Toy</span> bone <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token class-name">Dog</span> cuteDog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span>bone<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"자연스럽게 개방-폐쇄 원칙을 위반하게 된다."),"\n",t.createElement(a.p,null,"반면 DI 패턴이 적용된 구현코드는 수정이 필요없다. 이미 Dog 타입의 객체는 Toy 타입의 인터페이스에 의존하고 있고 Bone과 Doll은 모두 Toy를 구현하고 있기 때문이다.\n고수준 모듈에서 새로운 구현체를 주입하도록 설정",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Config</code>'}}),"만 변경해주면 된다."),"\n",t.createElement(a.p,null,"이런 의존관계를 설정해주는 고수준 모듈을 손쉽게 사용하기 위해 DI 프레임워크를 사용한다."),"\n",t.createElement(a.h1,{id:"di-프레임워크"},t.createElement(a.a,{href:"#di-프레임워크"},"DI 프레임워크")),"\n",t.createElement(a.img,{src:"https://velog.velcdn.com/images/aryumka/post/7f306d31-a0c8-40e8-91b5-6c791b188a07/image.png",alt:""}),"\n",t.createElement(a.p,null,"객체지향 패러다임을 포함하는 많은 프레임워크들에서 DI를 제공하고 있다."),"\n",t.createElement(a.p,null,"대표주자로는 자바(또는 코틀린) 기반 어플리케이션 프레임워크인 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Spring</code>'}}),"의 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">IoC Container</code>'}}),"가 있다. 자바, 안드로이드, 코틀린 네이티브, 코틀린 멀티플랫폼 등 다양한 환경을 지원하는  DI 프레임워크인 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Koin</code>'}}),", ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Javascript</code>'}}),"에서는 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">nest.js</code>'}})," 등이 DI 프레임워크를 제공한다.\n이러한 프레임워크들에서는 메타데이터를 이용, 의존관계를 주입하거나 객체 생성, 초기화, 사용(조회 등), 객체 소멸 같은 객체의 생명주기를 관리하는 역할을 한다."),"\n",t.createElement(a.p,null,"이러한 프레임워크들의 동작 원리를 이해하기 위해 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Kontainer</code>'}}),"라는 간단한 DI 컨테이너를 만들어보았다."),"\n",t.createElement(a.h2,{id:"kontainer-소개"},t.createElement(a.a,{href:"#kontainer-소개"},"Kontainer 소개")),"\n",t.createElement(a.p,null,t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Kontainer</code>'}}),"는 코틀린으로 작성했다.\n",t.createElement(a.a,{href:"https://github.com/aryumka/kontainer",rel:"nofollow noopener noreferrer"},"https://github.com/aryumka/kontainer")),"\n",t.createElement(a.p,null,"메이븐 중앙저장소에 배포되어있다."),"\n",t.createElement(a.p,null,"상세 내용은 다음과 같다."),"\n",t.createElement(a.h3,{id:"1-컨테이너-구조"},t.createElement(a.a,{href:"#1-컨테이너-구조"},"1. 컨테이너 구조")),"\n",t.createElement(a.p,null,"컨테이너는 코틀린의 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">object</code>'}})," 클래스를 이용, 싱글톤으로 구현했다.\n컨테이너가 갖는 필드들은 다음과 같다."),"\n",t.createElement(a.ul,null,"\n",t.createElement(a.li,null,"빈들의 메타데이터가 저장되는 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">registeredBean</code>'}})),"\n",t.createElement(a.li,null,"생성된 빈들이 저장되는 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">createdBean</code>'}})),"\n",t.createElement(a.li,null,"의존관계 그래프인 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">dependencyGraph</code>'}})),"\n",t.createElement(a.li,null,"의존관계 그래프의 간선을 저장한 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">edges</code>'}})),"\n",t.createElement(a.li,null,"각 빈들의 루트 빈의 정보를 저장하는 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">rootIndices</code>'}}),", ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">rootIdxMap</code>'}})),"\n"),"\n",t.createElement(a.blockquote,null,"\n",t.createElement(a.p,null,"여기서 빈은 프레임워크에 의해 관리되는 컴포넌트(인스턴스)이다.\n** 컴포넌트와 모듈의 차이: 컴포넌트는 런타임에 동적으로, 모듈은 컴파일 타임에 정적으로 존재한다."),"\n"),"\n",t.createElement(a.h3,{id:"2-빈-메타데이터-등록"},t.createElement(a.a,{href:"#2-빈-메타데이터-등록"},"2. 빈 메타데이터 등록")),"\n",t.createElement(a.p,null,"먼저 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Kontainer</code>'}}),"에게 어떤 인스턴스를 생성해야 하는지, 각 인스턴스들의 의존관계가 어떻게 되는지 등을 알려줘야 한다. 즉 데이터(객체)에 대한 데이터, ",t.createElement(a.strong,null,"메타데이터"),"를 제공해야 한다.\n프로그램을 실행하는 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">main</code>'}})," 함수에서 아래와 같이 빈을 등록한다."),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> kontainer <span class="token operator">=</span> <span class="token function">Kontainer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nkontainer<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>HelloService<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">)</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">register</code>'}})," 함수는 코틀린의 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Reflection</code>'}})," API(리플렉션 설명)를 이용하여 구현하였다."),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">register</span><span class="token punctuation">(</span>kClass<span class="token operator">:</span> KClass<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\tregisteredBean<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>kClass<span class="token punctuation">)</span>\n\trootIdxMap<span class="token punctuation">[</span>kClass<span class="token punctuation">]</span> <span class="token operator">=</span> registeredBean<span class="token punctuation">.</span>size <span class="token operator">-</span> <span class="token number">1</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"빈을 등록하면 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">registeredBean</code>'}}),"에 해당 객체의 메타데이터 ",t.createElement(a.a,{href:"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/",rel:"nofollow noopener noreferrer"},"KClass"),"가 추가된다."),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">private</span> <span class="token keyword">val</span> registeredBean <span class="token operator">=</span> mutableListOf<span class="token operator">&lt;</span>KClass<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//registeredBean: [class context.HelloService]</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"등록과 동시에 해당 빈의 루트를 저장할 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">rootIdxMap</code>'}}),"에 빈이 추가되는 순서대로 인덱스가 부여된다. 이 인덱스는 의존성 그래프를 그릴 때 사용된다."),"\n",t.createElement(a.p,null,t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Kontainer</code>'}}),"에서는 클래스, 생성자, 필드, 메서드 등 객체로써 메타데이터만 저장하지만 일반적인 DI 프레임워크에는 더 넓은 범위의 설정정보가 필요하다."),"\n",t.createElement(a.p,null,"컴포넌트로써의 속성, 즉 런타임에 프레임워크 내에서 어떻게 사용되는지에 대한 정보도 필요하기 때문이다. 빈의 생명주기를 결정하는 스코프, 인터페이스 사용 시 구현체 선택 정보 등이 이에 해당한다."),"\n",t.createElement(a.blockquote,null,"\n",t.createElement(a.p,null,"참고로 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Spring</code>'}}),"에서는 프로그램 내 코드 뿐만이 아닌 다양한 외부 설정으로 빈의 메타데이터를 제공할 수 있다.\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">.xml</code>'}})," 또는 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">.properties</code>'}}),"와 같은 설정파일이나 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Groovy</code>'}})," 스크립트 파일, 코드에 삽입하여 런타임에 설정되도록 하는 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">애너테이션</code>'}})," 등등으로 프로그램 구현 로직과 분리된 다양하고 높은 수준의 추상화가 가능하다. 각 설정마다 다른 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">ApplicationContext</code>'}})," 구현체로 구현된다."),"\n"),"\n",t.createElement(a.h3,{id:"3-빈-의존관계-설정-및-주입"},t.createElement(a.a,{href:"#3-빈-의존관계-설정-및-주입"},"3. 빈 의존관계 설정 및 주입")),"\n",t.createElement(a.p,null,t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Kontainer</code>'}}),"에서는 2에서 등록된 각 빈의 ",t.createElement(a.strong,null,"기본 생성자 파라미터"),"를 통해 의존관계를 파악하며 이를 의존관계 그래프 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">dependencyGraph</code>'}}),"로 나타낸다."),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">private</span> <span class="token keyword">val</span> dependencyGraph <span class="token operator">=</span> mutableMapOf<span class="token operator">&lt;</span>KClass<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">,</span> List<span class="token operator">&lt;</span>KClass<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token operator">></span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"이후 생성에 필요한 의존관계를 이 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">dependencyGraph</code>'}}),"에서 찾아 생성과 동시에 주입한다."),"\n",t.createElement(a.p,null,"예를 들어 아래와 같은 의존관계를 갖고 있는 클래스들을 등록 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">register</code>'}}),"했다고 가정하자."),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> E\n<span class="token keyword">class</span> B\n<span class="token keyword">class</span> C\n<span class="token keyword">class</span> <span class="token function">D</span><span class="token punctuation">(</span><span class="token keyword">val</span> e<span class="token operator">:</span> E<span class="token punctuation">)</span>\n<span class="token keyword">class</span> <span class="token function">A</span><span class="token punctuation">(</span>\n\t<span class="token keyword">val</span> b<span class="token operator">:</span> B<span class="token punctuation">,</span>\n    <span class="token keyword">val</span> c<span class="token operator">:</span> C<span class="token punctuation">,</span>\n    <span class="token keyword">val</span> d<span class="token operator">:</span> D\n<span class="token punctuation">)</span>\n<span class="token keyword">class</span> G\n<span class="token keyword">class</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token keyword">val</span> g<span class="token operator">:</span> G<span class="token punctuation">)</span>\n\n<span class="token keyword">val</span> kontainer <span class="token operator">=</span> Kontainer\n\nkontainer<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>A<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">)</span>\nkontainer<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>B<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">)</span>\nkontainer<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>C<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">)</span>\nkontainer<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>D<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">)</span>\nkontainer<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>E<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">)</span>\nkontainer<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>F<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">)</span>\nkontainer<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>G<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">)</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"다이어그램으로 표현하면 다음과 같다.\n",t.createElement(a.img,{src:"https://velog.velcdn.com/images/aryumka/post/fdeb4985-a8bf-4ca8-9754-1b2f2520d9a5/image.png",alt:""})),"\n",t.createElement(a.p,null,t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">registeredBean</code>'}}),"의 메타데이터를 참조하여 기본 생성자 파라미터를 가져와 의존관계 그래프 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">dependencyGraph</code>'}}),"와 간선정보 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">edges</code>'}}),"를 세팅한다."),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">setDependencyGraph</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t<span class="token keyword">for</span> <span class="token punctuation">(</span>bean <span class="token keyword">in</span> registeredBean<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    \t<span class="token keyword">val</span> <span class="token keyword">constructor</span> <span class="token operator">=</span> bean<span class="token punctuation">.</span>primaryConstructor<span class="token operator">!!</span>\n        <span class="token keyword">val</span> parameters <span class="token operator">=</span> <span class="token keyword">constructor</span><span class="token punctuation">.</span>parameters\n        <span class="token keyword">val</span> parameterTypes <span class="token operator">=</span> parameters<span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span>type<span class="token punctuation">.</span>classifier <span class="token keyword">as</span> KClass<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span> <span class="token punctuation">}</span>\n        dependencyGraph<span class="token punctuation">[</span>bean<span class="token punctuation">]</span> <span class="token operator">=</span> parameterTypes\n        \n        <span class="token keyword">for</span> <span class="token punctuation">(</span>parameter <span class="token keyword">in</span> parameterTypes<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        \tedges<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">Pair</span><span class="token punctuation">(</span>bean<span class="token punctuation">,</span> parameter<span class="token punctuation">)</span><span class="token punctuation">)</span>\n        <span class="token punctuation">}</span>\n\t<span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"그리고 의존관계 그래프를 탐색하여 순환참조가 발생하는지 확인 한다.\n이를 위해 의존관계에서 가장 상단에 있는 루트 노드를 확인한다.\n먼저 아래와 같이 자기 자신을 루트 노드로 초기화 해준 후"),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">initRootIndices</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\trootIndices <span class="token operator">=</span> <span class="token function">IntArray</span><span class="token punctuation">(</span>registeredBean<span class="token punctuation">.</span>size<span class="token punctuation">)</span>\n\t<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">in</span> rootIndices<span class="token punctuation">.</span>indices<span class="token punctuation">)</span> rootIndices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"간선 정보를 이용, 빈 등록 시 세팅해주었던 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">rootIdxMap</code>'}}),"을 함께 이용하여 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">UnionFind</code>'}})," 알고리즘을 통해 순환 참조가 있는지 파악한다."),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">unionFind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span>edge <span class="token keyword">in</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">val</span> <span class="token punctuation">(</span>parent<span class="token punctuation">,</span> child<span class="token punctuation">)</span> <span class="token operator">=</span> edge\n    <span class="token keyword">val</span> parentIndex <span class="token operator">=</span> rootIdxMap<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token operator">!!</span>\n    <span class="token keyword">val</span> childIndex <span class="token operator">=</span> rootIdxMap<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token operator">!!</span>\n    \n    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">in</span> rootIndices<span class="token punctuation">.</span>indices<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>rootIndices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> childIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t      <span class="token keyword">if</span> <span class="token punctuation">(</span>rootIndices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> rootIndices<span class="token punctuation">[</span>parentIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      \t\t<span class="token keyword">throw</span> <span class="token function">CircularDependencyException</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Circular Dependency for </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">parent</span></span><span class="token string"> and </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">child</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>\n    \t  <span class="token punctuation">}</span>\n      rootIndices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> rootIndices<span class="token punctuation">[</span>parentIndex<span class="token punctuation">]</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"순환참조가 탐지되지 않았다면 의존관계 그래프에 담겨있는 메타데이터를 참조해 빈을 생성하고 주입한다."),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">createBeans</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">in</span> rootIndices<span class="token punctuation">.</span>indices<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>rootIndices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t    <span class="token function">createBean</span><span class="token punctuation">(</span>registeredBean<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dependencyGraph<span class="token punctuation">[</span>registeredBean<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">!!</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">//재귀적으로 탐색하여 아무 객체에도 의존하지 않는 것부터 생성</span>\n<span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">createBean</span><span class="token punctuation">(</span>parent<span class="token operator">:</span> KClass<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">,</span> children<span class="token operator">:</span>List<span class="token operator">&lt;</span>KClass<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">in</span> children<span class="token punctuation">.</span>indices<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t\t<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>createdBean<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>simpleName<span class="token operator">!!</span><span class="token punctuation">)</span> <span class="token operator">||</span> createdBean<span class="token punctuation">[</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>simpleName<span class="token operator">!!</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t\t\t<span class="token function">createBean</span><span class="token punctuation">(</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dependencyGraph<span class="token punctuation">[</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">!!</span><span class="token punctuation">)</span>\n\t\t<span class="token punctuation">}</span>\n\t<span class="token punctuation">}</span>\n\tcreatedBean<span class="token punctuation">[</span>parent<span class="token punctuation">.</span>simpleName<span class="token operator">!!</span><span class="token punctuation">]</span> <span class="token operator">=</span> parent<span class="token punctuation">.</span>primaryConstructor<span class="token operator">!!</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token operator">*</span>children<span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">{</span> createdBean<span class="token punctuation">[</span>it<span class="token punctuation">.</span>simpleName<span class="token operator">!!</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">toTypedArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre></div>'}}),"\n",t.createElement(a.p,null,"일반적으로 사용되는 DI 프레임워크들의 경우 기본생성자 외에도 다양한 방법의 DI가 가능하다."),"\n",t.createElement(a.p,null,"생성자가 여러 개일 때 DI 컨테이너가 어떤 생성자를 사용해야 하는지 알려줄 수도 있으며 생성자 주입이 아닌 생성 이후 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">setter</code>'}})," 메서드 등으로 필드 주입을 할수도 있다."),"\n",t.createElement(a.blockquote,null,"\n",t.createElement(a.p,null,"필드 주입의 경우 생성 시점과 주입 시점이 다르다. 주입시점에 이미 컨테이너 자신이 생성한 빈을 가져와 주입하며 이 때 주입될 빈이 생성되지 않았다면  ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">NullPointerException</code>'}}),"가 발생한다. 순환참조 관계를 미리 알 수 없으므로 어플리케이션 실행 중 순환참조 문제가 발생할 수도 있다. ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Spring</code>'}}),"의 경우 공식적으로 생성자 주입을 권장하고 있다."),"\n"),"\n",t.createElement(a.h3,{id:"4-생명주기-관리"},t.createElement(a.a,{href:"#4-생명주기-관리"},"4. 생명주기 관리")),"\n",t.createElement(a.p,null,t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Kontainer</code>'}}),"에서는 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">start</code>'}})," 메서드를 통해 모든 빈을 일괄적으로 생성하고 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">end</code>'}})," 메서드를 통해 모든 빈을 삭제한다. 이외의 별도의 생명주기 관리는 없다."),"\n",t.createElement(a.p,null,"일반적인 DI 프레임워크들에서는 단순한 객체 생성 및 의존관계 주입뿐만이 아닌 초기화 또는 파괴(destruct)와 그에 따른 콜백 실행 등 전체 생명주기를 관리한다."),"\n",t.createElement(a.p,null,"이러한 생명주기는 각 빈의 스코프에 따라 달라질 수 있다.\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Kontainer</code>'}}),"에서는 오직 싱글톤 인스턴스만 등록할 수 있지만 일반적인 프레임워크들에서는 객체의 목적에 따라 다양한 스코프의 빈을 지원하기도 한다."),"\n",t.createElement(a.blockquote,null,"\n",t.createElement(a.p,null,t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Spring</code>'}}),"의 경우 singleton, prototype, request, session, application, websocket ",t.createElement(a.a,{href:"https://docs.spring.io/spring-framework/reference/core/beans/factory-scopes.html",rel:"nofollow noopener noreferrer"},"총 6개의 스코프"),"를 지원한다.\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Koin</code>'}}),"의 경우 ",t.createElement(a.a,{href:"https://insert-koin.io/docs/reference/koin-core/scopes",rel:"nofollow noopener noreferrer"},"커스텀 스코프"),"를 만들어서 사용할 수 있다."),"\n"),"\n",t.createElement(a.h3,{id:"5-빈-사용"},t.createElement(a.a,{href:"#5-빈-사용"},"5. 빈 사용")),"\n",t.createElement(a.p,null,t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Kontainer</code>'}}),"에서는 컨테이너 생성 후 등록한 빈을 아래와 같이 가져와 사용한다."),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> kontainer <span class="token operator">=</span> Kontainer\nkontainer<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>HelloService<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">)</span>\nkontainer<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>HelloDao<span class="token operator">::</span><span class="token keyword">class</span><span class="token punctuation">)</span>\nkontainer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n<span class="token keyword">val</span> bean <span class="token operator">=</span> kontainer<span class="token punctuation">.</span>getBean<span class="token operator">&lt;</span>HelloService<span class="token operator">></span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"HelloService"</span></span><span class="token punctuation">)</span></code></pre></div>'}}),"\n",t.createElement(a.h2,{id:"보완하고-싶은-점"},t.createElement(a.a,{href:"#보완하고-싶은-점"},"보완하고 싶은 점")),"\n",t.createElement(a.ul,null,"\n",t.createElement(a.li,null,"빈의 이름을 지정하는 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Qualifier</code>'}}),", 스코프 등 빈에 대한 상세한 설정이 필요하다."),"\n",t.createElement(a.li,null,"빈 설정을 네이티브 코드가 아닌 다양한 방법으로 지원할 수 있다면 좋겠다. 특히 애너테이션을 통한 빈 설정이 최우선순위."),"\n",t.createElement(a.li,null,"필드 주입 등 다양한 DI 방법을 추가하고 싶다."),"\n",t.createElement(a.li,null,"추가된 다양한 DI 방법 및 설정에 따라 추상화된 구조를 만들어야 한다."),"\n",t.createElement(a.li,null,"컨테이너 내 역할에 따른 객체지향적 설계가 필요하다. 현재는 모든 기능이 단일 클래스 안에 구현되어 있다."),"\n",t.createElement(a.li,null,"적절한 모듈화가 이루어져야 한다. 예를 들어 빈 등록 같은 설정을 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">main</code>'}}),"함수에서 호출하는 것보다는 별도의 설정파일에서 설정, ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">main</code>'}}),"에서는 이를 참조만 하는 것이 바람직하다."),"\n"),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token comment">//koin api 호출 예시</span>\n<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">vararg</span> args <span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token comment">// Start Koin</span>\n    startKoin <span class="token punctuation">{</span>\n        <span class="token function">modules</span><span class="token punctuation">(</span>myModule<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// Create MyComponent instance and inject from Koin container</span>\n    <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> MyService\n<span class="token comment">// 모듈 설정</span>\n<span class="token keyword">val</span> myModule <span class="token operator">=</span> module <span class="token punctuation">{</span>\n    <span class="token comment">// Define a singleton for MyService</span>\n    single <span class="token punctuation">{</span> <span class="token function">MyService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",t.createElement(a.ul,null,"\n",t.createElement(a.li,null,t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">getBean</code>'}})," 함수에서 타입 파라미터 이외에도 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">name: String</code>'}}),"을 넣어줘야 한다. 중복적이고 불필요한 코드이므로 개선이 필요하다."),"\n"),"\n",t.createElement(a.h1,{id:"마치며"},t.createElement(a.a,{href:"#마치며"},"마치며")),"\n",t.createElement(a.p,null,"스프링을 처음 배웠을 때의 기억이 아직도 생생하다.\n이게 뭔지 또 이걸 왜 써야하는지 머릿속에 물음표만이 가득했다."),"\n",t.createElement(a.p,null,"이후 실무에서도 숨쉬듯 익숙하게 스프링을 써오면서도 IoC 컨테이너의 동작원리나 근본적인 존재 이유에 대해 생각하면 늘 먹구름이 낀 것처럼 흐릿했다."),"\n",t.createElement(a.p,null,"직접 DI 컨테이너를 만들어 보고 글로 정리하고 보니 이제야 긴 숙제를 마친 기분이다."),"\n",t.createElement(a.p,null,"텍스트로만 존재했던 스프링에 대한 파편화된 지식이 이번 경험을 통해 각자의 맥락을 찾아 하나로 연결되어 자리잡을 수 있었다."),"\n",t.createElement(a.p,null,"당연한 말이지만 세상에 당연히 되는 건 없다.\n우리가 사용하는 모든 소프트웨어는 마법같이 태어나 존재하는 것이 아니라 우리가 이해할 수 있는 논리와 설계로 이루어진다. 자료구조와 알고리즘이 그 뼈대가 된다는 것도 이번 기회를 통해 직접 피부로 느낄 수 있었다."),"\n",t.createElement(a.p,null,"다음 바퀴를 만들 때는 또 무엇을 배울 수 있을지 기대된다."))}a.default=function(n){void 0===n&&(n={});const{wrapper:a}=Object.assign({},(0,e.R)(),n.components);return a?t.createElement(a,n,t.createElement(p,n)):p(n)}}}]);
//# sourceMappingURL=9bbc7597de3be48ea08a45e259596dae8f7e9882-70548a479e13a7425d04.js.map