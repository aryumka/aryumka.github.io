"use strict";(self.webpackChunkaryumka_me=self.webpackChunkaryumka_me||[]).push([[3683],{4662:function(n,a,s){s.r(a);var e=s(9128),t=s(9474);function p(n){const a=Object.assign({h1:"h1",a:"a",ul:"ul",li:"li",p:"p",strong:"strong",blockquote:"blockquote",em:"em",span:"span",h2:"h2",h3:"h3",ol:"ol"},(0,e.R)(),n.components);return t.createElement(t.Fragment,null,t.createElement(a.h1,{id:"0-문제의식"},t.createElement(a.a,{href:"#0-문제의식"},"0. 문제의식")),"\n",t.createElement(a.ul,null,"\n",t.createElement(a.li,null,"사내 슬랙에 에러 로그가 쌓이는데 어떤 것이 진짜 중요한 오류인지 알 수 없었다."),"\n",t.createElement(a.li,null,"언제 어떤 예외를 던져야 하는지, 커스텀 예외는 얼마나 만들어 써야 할지 명확한 기준이 없었다."),"\n"),"\n",t.createElement(a.h1,{id:"1-서론"},t.createElement(a.a,{href:"#1-서론"},"1. 서론")),"\n",t.createElement(a.p,null,"한가로운 주말 아침, 유튜브 알고리즘이 날 한 영상으로 이끌었다. 왜 리눅스의 창시자인 리누스 토르발즈가 커널 개발에 C++를 극도로 반대하는지에 대한 영상이었다. ",t.createElement(a.a,{href:"https://yarchive.net/comp/linux/c++.html",rel:"nofollow noopener noreferrer"},t.createElement(a.strong,null,"리누스 토르발즈의 C++ 혐오")),"는 유명한데, 그는 심지어 C++가 ",t.createElement(a.strong,null,"근본적으로 잘못된 언어"),"라며 대표적인 예로 **예외 처리(Exception Handling)**를 들었다."),"\n",t.createElement(a.blockquote,null,"\n",t.createElement(a.p,null,"C++의 예외 처리는 근본적으로 망가졌다. 특히 커널 개발용으로는 아예 박살이 나 있다.\n(",t.createElement(a.em,null,"the whole C++ exception handling thing is fundamentally broken. It's ",t.createElement(a.strong,null,"especially")," broken for kernels."),")"),"\n"),"\n",t.createElement(a.p,null,"뒤통수를 맞은 느낌이었다. 예외를 던지지 않고 개발을 할 수 있다고?\n그렇다면 C나 전통적인 절차적 프로그래밍에는 ",t.createElement(a.strong,null,"예외"),"라는 개념이 없었던 걸까?"),"\n",t.createElement(a.h1,{id:"2-절차적-예외-처리"},t.createElement(a.a,{href:"#2-절차적-예외-처리"},"2. 절차적 예외 처리")),"\n",t.createElement(a.p,null,"그렇다. C 언어에는 자바나 C++ 같은 객체지향 언어들이 가진 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">try-catch</code>'}}),"나 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Exception</code>'}})," 객체가 없다. 대신 에러 상태를 리턴 값으로 내려주고 호출부에서 이를 검증하는 방식이 일반적이다."),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    FILE <span class="token operator">*</span>file <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"data.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>file <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"파일 열기 실패"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 에러 코드 반환</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token function">fclose</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 정상 종료</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"이런 방식은 자바의 오래된 레거시 코드에서도 흔히 볼 수 있다. 하지만 명확한 한계를 갖고 있다."),"\n",t.createElement(a.ul,null,"\n",t.createElement(a.li,null,"호출부에서 정상 값과 오류 값을 혼동할 수 있다."),"\n",t.createElement(a.li,null,"에러가 발생한 이유를 명확히 알기 어렵다."),"\n"),"\n",t.createElement(a.p,null,"이를 보완하기 위해 에러 메시지를 문자열로 담은 구조체를 리턴하기도 한다."),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="java"><pre class="language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FileReader</span> <span class="token punctuation">{</span>\n  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> <span class="token function">readFile</span><span class="token punctuation">(</span><span class="token class-name">String</span> path<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">Path</span> filePath <span class="token operator">=</span> <span class="token class-name">Paths</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Files</span><span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token class-name">Map</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"success"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"error"</span><span class="token punctuation">,</span> <span class="token string">"파일이 존재하지 않습니다."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> lines <span class="token operator">=</span> <span class="token class-name">Files</span><span class="token punctuation">.</span><span class="token function">readAllLines</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token class-name">Map</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"success"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token string">"content"</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">"\\n"</span><span class="token punctuation">,</span> lines<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"실제 외부 API와 통신할 때도 이런 식의 문자열 응답을 자주 볼 수 있다. 이런 방식도 몇 가지 문제가 있다."),"\n",t.createElement(a.ul,null,"\n",t.createElement(a.li,null,"호출 후 결과를 사용하기 전 매번 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">if</code>'}}),"로 정상 값 검사해야 함 → ",t.createElement(a.strong,null,"보일러 플레이트 증가")),"\n",t.createElement(a.li,null,"에러 원인이 문자열로 주어져 상황에 맞는 대응이 어려움 → ",t.createElement(a.strong,null,"유연성 저하")),"\n",t.createElement(a.li,null,"에러가 발생한 경우에도 호출부에서 처리를 강제할 수 없고 복구가 불가능한 상황에서도 계속 진행을 시도할 수 있음 → ",t.createElement(a.strong,null,"예외 처리 강제성 부재")),"\n",t.createElement(a.li,null,"컴파일 타임에 실수를 알 수 없음 → ",t.createElement(a.strong,null,"치명적 결과로 이어질 수 있음")," ☠️"),"\n"),"\n",t.createElement(a.p,null,"어차피 실패인데 왜 끝까지 실행되어야 할까? 더군다나 한번의 실수가 치명적인 오류 전파로 이어질 수 있다면?\n결국 이런 방식은 실수하기 너무 쉽다. 실패할 상황이라면 차라리 빨리 포기하는 게 낫지 않을까?"),"\n",t.createElement(a.h1,{id:"3-자바의-예외-처리"},t.createElement(a.a,{href:"#3-자바의-예외-처리"},"3. 자바의 예외 처리")),"\n",t.createElement(a.h2,{id:"fail-fast-and-throw"},t.createElement(a.a,{href:"#fail-fast-and-throw"},"Fail Fast and Throw")),"\n",t.createElement(a.p,null,"리누스가 극혐했던 객체지향 언어들(C++, Java 등)은 예외를 던지고 받는 방식을 쓴다. 특히 자바는 ",t.createElement(a.strong,null,"Fail Fast")," 철학을 따른다. 문제가 있을 때 빠르게 실패해 버그를 즉시 드러내는 방식이다."),"\n",t.createElement(a.p,null,"빨리 실패해야 빨리 고칠 수 있다."),"\n",t.createElement(a.p,null,"자바의 예외는 크게 두 가지로 나눈다. 바로 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Checked Exception</code>'}}),"과 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Unchecked Exception</code>'}}),"이다."),"\n",t.createElement(a.h2,{id:"checked-exception"},t.createElement(a.a,{href:"#checked-exception"},"Checked Exception")),"\n",t.createElement(a.p,null,t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Checked Exception</code>'}}),"은 C++ 등 대부분 언어에는 존재하지 않는 자바만의 독특한 예외 처리 방식이다. 대표적인 예로 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">IOException</code>'}}),"이 있다."),"\n",t.createElement(a.p,null,t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Checked Exception</code>'}}),"은 ",t.createElement(a.strong,null,"컴파일러가 반드시")," 예외 처리를 요구한다. 주로 일반적, 예측가능한 비즈니스 케이스에서 사용하라고 의도된 디자인이다. 심지어 스프링에서는 아래처럼 던져도 롤백조차 되지 않는다."),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="java"><pre class="language-java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span>\n<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>\n    <span class="token keyword">try</span> <span class="token punctuation">{</span>\n        <span class="token comment">//파일 처리 등</span>\n    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">throw</span> e<span class="token punctuation">;</span> <span class="token comment">// Checked Exception → Spring은 롤백 안 함</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"실패 가능한 경우가 메서드 시그니처에 나와있으므로 ",t.createElement(a.strong,null,"API가 어떤 예외를 던질 수 있는지")," 명시적이라는 장점이 있다. 코드 자체가 문서화된다."),"\n",t.createElement(a.p,null,"그러나 오히려 이 때문에 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">CheckedException</code>'}}),"은 예외가 어플리케이션 전역에 전염된다는 치명적인 단점이 있다. 이를 방지하기 위해 호출부에서 무의미한 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">try catch</code>'}}),"가 남용되기도 한다."),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="java"><pre class="language-java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>\n    userService<span class="token punctuation">.</span><span class="token function">updateLastLogin</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 예외가 발생해도 아무것도 하지 않음.</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"위와 비슷한 이유들로 이제는 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Checked Exception</code>'}}),"을 사용하지 않는 추세이고 심지어 안티패턴으로 간주, 사용하지 않기를 권장하기도 한다."),"\n",t.createElement(a.blockquote,null,"\n",t.createElement(a.p,null,"💡 Scala 3에는 최근 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">CheckedException</code>'}}),"과 비슷한 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">canThrow</code>'}}),"가 추가되었다. ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">canThrow</code>'}}),"는 예외가 던져질 수 있음을 타입 시스템으로 강제한다. 즉 예외도 타입의 일부로 취급된다."),"\n"),"\n",t.createElement(a.h2,{id:"스프링의-예외-처리"},t.createElement(a.a,{href:"#스프링의-예외-처리"},"스프링의 예외 처리")),"\n",t.createElement(a.p,null,"자바의 철학을 이어받은 스프링에서는 주로 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">RuntimeException</code>'}}),"을 사용한다. 스프링 DB 사용 시 자동 롤백을 지원하고 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">@ControllerAdvice</code>'}}),"를 통해 전역 예외 처리가 가능하다. 즉 ",t.createElement(a.strong,null,"매우 편리"),"하다."),"\n",t.createElement(a.p,null,"비즈니스 맥락을 표현하기 위해 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">RuntimeException</code>'}}),"을 상속한 커스텀 예외들을 사용하기도 한다."),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="java"><pre class="language-java"><code class="language-java"><span class="token annotation punctuation">@RestControllerAdvice</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GlobalExceptionHandler</span> <span class="token punctuation">{</span>\n    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token class-name">BusinessException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>\n    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ErrorResponse</span><span class="token punctuation">></span></span> <span class="token function">handleBusinessException</span><span class="token punctuation">(</span><span class="token class-name">BusinessException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token class-name">ResponseEntity</span><span class="token punctuation">.</span><span class="token function">badRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">body</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ErrorResponse</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"하지만 지나치게 세분화된 예외는 가독성을 떨어뜨리고 전역 처리의 의미를 희석시킨다.\n특히 커스텀 예외들은 비즈니스 상황마다 다르게 처리되어야 할 수 있으나 전역으로 처리된 비즈니스 예외들은 그저 메시지 전달이나 로깅 처리에 그치고 만다."),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="java"><pre class="language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token class-name">String</span> inputPassword<span class="token punctuation">,</span> <span class="token class-name">String</span> actualPassword<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isPasswordMismatch</span><span class="token punctuation">(</span>inputPassword<span class="token punctuation">,</span> actualPassword<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n       <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InvalidPasswordException</span><span class="token punctuation">(</span><span class="token string">"입력한 비밀번호가 올바르지 않습니다."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"사실 이런 커스텀 예외들은 애초에 처리가 필요 없을 수도 있다."),"\n",t.createElement(a.blockquote,null,"\n",t.createElement(a.p,null,t.createElement(a.em,null,"사용자가 비밀번호를 틀렸다는 오류를 개발자가 확인해야 할까?")),"\n"),"\n",t.createElement(a.p,null,"보통 모니터링 툴은 예외가 던져지고 처리되지 않으면 에러 레벨로 간주한다. 볼 필요가 없는 오류가 쌓이면 정말 처리되어야 하는 예외가 묻힐 확률은 높아진다."),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="java"><pre class="language-java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>\n    userService<span class="token punctuation">.</span><span class="token function">login</span><span class="token punctuation">(</span>inputPassword<span class="token punctuation">,</span> actualPassword<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InvalidPasswordException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"로그인 실패: "</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">try catch</code>'}}),"로 잡는다고 해도 마찬가지다. 가독성은 가독성대로, 성능은 성능대로 희생하는 악수",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">惡手</code>'}}),"다."),"\n",t.createElement(a.p,null,"모니터링 채널에서 ",t.createElement(a.strong,null,"안봐도 되는 오류라면 그냥 처음부터 던지지 말아야")," 한다. 일단 던지고 잡는다? 위에서 본 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">CheckedException</code>'}}),"의 무의미한 던지고 받기와 다를 바 없다. 로그 한줄 남기려고 던지기에 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">try catch</code>'}}),"의 비용은 저렴하지 않다."),"\n",t.createElement(a.p,null,"더 큰 문제는 ",t.createElement(a.strong,null,"제어 상실"),"에 있다. 처리되지 않은 예외는 즉시 코드 흐름을 중단시키며 전체 프로그램의 예측 가능성을 크게 떨어뜨린다."),"\n",t.createElement(a.p,null,"자신이 작성한 프로그램이라도 코드레벨에서 각 메서드에서 어떤 예외가 언제 어떻게 발생할지 정확히 파악하기는 어렵다. 예외 발생 경로를 꼼꼼히 문서화하는 경우도 드물다."),"\n",t.createElement(a.h1,{id:"4-예외를-바라보는-다른-시각"},t.createElement(a.a,{href:"#4-예외를-바라보는-다른-시각"},"4. 예외를 바라보는 다른 시각")),"\n",t.createElement(a.h2,{id:"계약-위반"},t.createElement(a.a,{href:"#계약-위반"},"계약 위반")),"\n",t.createElement(a.p,null,t.createElement(a.strong,null,"Method Signature"),"는 정말 액면 그대로의 서명",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Signature</code>'}}),"이라는 뜻이다."),"\n",t.createElement(a.p,null,"인터페이스를 계약이라고 본다면 ",t.createElement(a.strong,null,"예외는 계약 위반"),"이라고 봐야 마땅하다. 리턴받기로 약속하고 서명한 값 대신 에러가 돌아왔기 때문이다.\n지금은 무시받는 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">CheckedException</code>'}}),"이지만 자바 디자이너들의 의도도 비슷했을 것이다."),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="java"><pre class="language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">;</span> <span class="token comment">// 메서드 시그니처에서 String을 반환하거나 IOException을 던진다는 계약</span></code></pre></div>'}}),"\n",t.createElement(a.blockquote,null,"\n",t.createElement(a.p,null,"원래 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">method signature</code>'}}),"는 컴파일러가 메서드를 정확히 찾아가기 위한 서명, 즉 고유 식별자를 뜻한다. 메서드 이름과 인자만 해당되며 리턴 타입은 포함되지 않는다. 컴파일러는 리턴 타입만 가지고 어떤 메서드인지 정확히 판단할 수 없기 때문이다."),"\n"),"\n",t.createElement(a.p,null,"물론 계약은 위반될 수 있다. 하지만 쉽게 위반되는 계약은 좋은 계약이 아니다."),"\n",t.createElement(a.blockquote,null,"\n",t.createElement(a.p,null,"상법에도 계약 상 불가항력",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Force Majeure</code>'}}),"이라는 개념이 있다. 전쟁이나 천재지변 같은 사건이 발생하면 계약은 무효가 된다."),"\n"),"\n",t.createElement(a.p,null,"즉, 예외를 아예 안던질 순 없다. 프로그램 부팅 시 포트가 이미 사용 중이라면? 그냥 던져버리고 프로그램을 종료하는 게 맞다."),"\n",t.createElement(a.p,null,"하지만 찾고 있는 유저의 ID가 DB에 없는 상황이라면? 입력한 날짜가 유효하지 않는 날짜라면? 이건 천재지변보다는 완벽하게 예상 가능한 비즈니스 케이스에 가깝다."),"\n",t.createElement(a.h2,{id:"값으로서의-예외"},t.createElement(a.a,{href:"#값으로서의-예외"},"값으로서의 예외")),"\n",t.createElement(a.p,null,t.createElement(a.strong,null,"함수형 프로그래밍"),"에서는 예외 던지기를 **부수 효과",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">side effect</code>'}}),"**라고 여긴다.\n부수효과는 함수가 결과를 리턴하는 것 이외에 다른 일을 하는 행위를 뜻한다. 참조투명성과 순수성을 보장하기 위해서는 실행 중 잘못된 상황이 발생해도 제어 흐름에 영향이 없어야 한다."),"\n",t.createElement(a.p,null,"그래서 값으로 예외를 리턴한다."),"\n",t.createElement(a.p,null,"그렇다면 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">false</code>'}}),"나 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">-1</code>'}})," 등의 에러 값을 표현하는 ",t.createElement(a.strong,null,"절차적 프로그래밍"),"과 무엇이 다를까? 가장 큰 특징은 유효하지 않은 값이라는 것을 컴파일 단계에서 명확하게 알 수 있다는 점이다."),"\n",t.createElement(a.h3,{id:"null"},t.createElement(a.a,{href:"#null"},"Null")),"\n",t.createElement(a.p,null,"무엇인가 잘못되었을 때 가장 직관적으로 떠올릴 리턴 값은 아마도 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">null</code>'}}),"일 것이다. 실무에서도 해당 없는 값을 화면에 표시할 때 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">null</code>'}}),"을 리턴하는 경우도 많다."),"\n",t.createElement(a.p,null,"그러나 많이 사용하는 방법이라고 좋은 방법은 아니다."),"\n",t.createElement(a.p,null,"null 직접 참조를 피하기 위해 즉각적인 검사 코드가 필요하다. 결국 절차적 프로그래밍의 예외처리와 유사한 문제들이 발생한다."),"\n",t.createElement(a.h3,{id:"optional"},t.createElement(a.a,{href:"#optional"},"Optional")),"\n",t.createElement(a.p,null,"자바 8에서 함수형 API들과 함께 도입된 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Optional</code>'}}),"은 값이 있을 수도 있고 없을 수도 있다는 것을 표현하는 타입 빌더이다."),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="java"><pre class="language-java"><code class="language-java"><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> name <span class="token operator">=</span> <span class="token function">findUserNameById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>\nname<span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"오류가 발생하지 않았다는 가정 하에 null을 직접 다루지 않고 안전한 방식으로 연산을 이어나가고 필요할 때 꺼내 쓸 수 있다."),"\n",t.createElement(a.p,null,"하지만 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Optional</code>'}}),"은 실패에 대한 이유를 담지 못한다는 한계가 있다."),"\n",t.createElement(a.p,null,"만약 DB에서 무언가 조회하는 메서드에서 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Optional.EMPTY</code>'}}),"를 반환한다면 어떤 의미일까? 값이 없다는 의미일까? 아니면 DB 연결이 끊겼다는 의미일까?\n사용자에게 입력을 유도해야 할까? 조금 이따 재시도를 유도해야 할까?"),"\n",t.createElement(a.p,null,"단순한 존재 여부만 표현할 수 있기 때문에, 실패 원인이 중요할 때는 적절하지 않다."),"\n",t.createElement(a.h3,{id:"result"},t.createElement(a.a,{href:"#result"},"Result")),"\n",t.createElement(a.p,null,"우리는 예외로서의 값과 실패 사유를 모두 알고 싶다.\n코틀린에서는 자체적으로 Result 객체를 제공한다. 성공과 실패를 명확히 구분하고 실패의 이유를 전달한다."),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token comment">// runCatching에서 리턴되는 객체가 Result!</span>\nrunCatching <span class="token punctuation">{</span> userService<span class="token punctuation">.</span><span class="token function">getUser</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token punctuation">}</span>\n    <span class="token punctuation">.</span><span class="token function">onSuccess</span> <span class="token punctuation">{</span> user <span class="token operator">-></span> <span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token punctuation">}</span>\n    <span class="token punctuation">.</span><span class="token function">onFailure</span> <span class="token punctuation">{</span> e <span class="token operator">-></span> log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"사용자 조회 실패"</span></span><span class="token punctuation">,</span> e<span class="token punctuation">)</span> <span class="token punctuation">}</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"자바로 구현하면 이런 식으로 생겼다."),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="java"><pre class="language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">{</span>\n\n    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">T</span> value<span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Throwable</span> error<span class="token punctuation">;</span>\n\t<span class="token comment">// 생성자 생략</span>\n    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> error <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isFailure</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> error <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token comment">// ...</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"함수형이라고 표현했지만 사실 이거 자바개발자들에게도 익숙한 구조다. http 응답으로 내려주는 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Response</code>'}})," 객체와 비슷하다. 생각해보면 당연하다.\n내 서버의 오류 응답은 null이나 empty로 내리고 코드나 로그로 원인을 확인할 수 있지만 원격으로 내려오는 응답이라면? ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Result</code>'}})," 같은 객체 사용은 더 이상 선택 사항이 아니다."),"\n",t.createElement(a.p,null,"만약 에러 자체도 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">RuntimeException</code>'}}),"이 아닌 커스텀 객체를 사용하고 싶다면 타입 파라미터를 추가할 수도 있다."),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="java"><pre class="language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Result</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">{</span>\n\n    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">T</span> value<span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">E</span> error<span class="token punctuation">;</span>\n    <span class="token comment">// ...</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",t.createElement(a.blockquote,null,"\n",t.createElement(a.p,null,"함수형에서 이런 스타일은 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Either&lt;L, R></code>'}}),"라고 통용된다. 일반적으로 오른쪽",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Right</code>'}}),"에 있는 것이 올바른",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Right</code>'}})," 값이다."),"\n"),"\n",t.createElement(a.p,null,t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Result</code>'}})," 객체를 이용하면 예외가 발생할 수 있는 메서드를 코틀린으로 아래와 같이 구현할 수 있다."),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">InvalidPasswordError</span><span class="token punctuation">(</span><span class="token keyword">override</span> <span class="token keyword">val</span> msg<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token operator">:</span> ResultError <span class="token comment">// 직접 만든 커스텀 에러 인터페이스</span>\n\n<span class="token keyword">fun</span> <span class="token function">checkPassword</span><span class="token punctuation">(</span>input<span class="token operator">:</span> String<span class="token punctuation">,</span> <span class="token keyword">actual</span><span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span> Result<span class="token operator">&lt;</span>InvalidPasswordError<span class="token punctuation">,</span> String<span class="token operator">></span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>input <span class="token operator">==</span> <span class="token keyword">actual</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        input<span class="token punctuation">.</span><span class="token function">asSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n        <span class="token function">InvalidPasswordError</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"비밀번호가 일치하지 않습니다."</span></span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">asFailure</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"사용하는 쪽은 다음과 같이 구현된다."),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> result <span class="token operator">=</span> <span class="token function">checkPassword</span><span class="token punctuation">(</span>inputPassword<span class="token punctuation">,</span> actualPassword<span class="token punctuation">)</span>\n<span class="token keyword">val</span> password <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">onFailure</span> <span class="token punctuation">{</span> error <span class="token operator">-></span>\n    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"로그인 실패: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token expression">error<span class="token punctuation">.</span>msg</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>\n    <span class="token keyword">return</span>  <span class="token comment">// 여기서 탈출</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"로그인 성공. 비밀번호: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">password</span></span><span class="token string">"</span></span><span class="token punctuation">)</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"단순히 예외가 던져지지 않기에 실패로 끝나지 않고 재처리",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">retry</code>'}}),", 복구",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">recover</code>'}})," 등의 사후처리도 쉽고 구조적으로 가능하다."),"\n",t.createElement(a.p,null,"예를 들어 외부에서 카드 내역 스크래핑 api 요청 로직이라면 실패할 때 재처리가 필요할 수 있다."),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> message<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token function">fetchCardHistory</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\t<span class="token comment">// 실패 시 재시도</span>\n    <span class="token punctuation">.</span><span class="token function">orElseRetry</span> <span class="token punctuation">{</span> <span class="token function">fetchCardHistory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>\n    <span class="token comment">// 성공한 경우 결과를 사용</span>\n    <span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">{</span> list <span class="token operator">-></span> <span class="token string-literal singleline"><span class="token string">"총 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token expression">list<span class="token punctuation">.</span>size</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">건의 카드 내역이 있습니다."</span></span> <span class="token punctuation">}</span>\n    <span class="token comment">// 실패한 경우 캐시에서 불러옴</span>\n    <span class="token punctuation">.</span><span class="token function">recoverWith</span> <span class="token punctuation">{</span> error <span class="token operator">-></span>\n        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"재시도 후에도 실패. 캐시에서 불러옵니다."</span></span><span class="token punctuation">)</span>\n        <span class="token function">fetchCardHistoryFromCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"제어 흐름이 한눈에 보이고 예외 처리가 더 자유로워진다. 코틀린에서 제공하는 확장함수는 이런 에러처리를 편리하게 구현할 수 있게 도와준다."),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token comment">// Result의 확장함수로 정의</span>\n<span class="token keyword">fun</span> <span class="token operator">&lt;</span>E <span class="token operator">:</span> ResultError<span class="token punctuation">,</span> T<span class="token operator">></span> Result<span class="token operator">&lt;</span>E<span class="token punctuation">,</span> T<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">orElseRetry</span><span class="token punctuation">(</span>\n    fallback<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Result<span class="token operator">&lt;</span>E<span class="token punctuation">,</span> T<span class="token operator">></span>\n    <span class="token comment">// 실패 시 재처리 로직을 넣어준다. 횟수나 조건 등을 넣어 정교하게 만들 수도 있다.</span>\n<span class="token punctuation">)</span><span class="token operator">:</span> Result<span class="token operator">&lt;</span>E<span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token operator">=</span> <span class="token keyword">when</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">is</span> Success <span class="token operator">-></span> <span class="token keyword">this</span>\n    <span class="token keyword">is</span> Failure <span class="token operator">-></span> <span class="token function">fallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">fun</span> <span class="token operator">&lt;</span>E <span class="token operator">:</span> ResultError<span class="token punctuation">,</span> T<span class="token operator">></span> Result<span class="token operator">&lt;</span>E<span class="token punctuation">,</span> T<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">recoverWith</span><span class="token punctuation">(</span>\n\tf<span class="token operator">:</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> <span class="token operator">-></span> Result<span class="token operator">&lt;</span>E<span class="token punctuation">,</span> T<span class="token operator">></span>\n<span class="token punctuation">)</span><span class="token operator">:</span> Result<span class="token operator">&lt;</span>Nothing<span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token operator">=</span> <span class="token keyword">when</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">is</span> Success <span class="token operator">-></span> <span class="token keyword">this</span>\n    <span class="token keyword">is</span> Failure <span class="token operator">-></span> <span class="token function">f</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"하지만 스프링을 사용하는 사람들에게 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">RuntimeException</code>'}}),"는 포기할 수 없는 편리함이다. 만약 서비스 단에서 예외를 던져 롤백을 발생시키고 싶다면 아래와 같이 예외를 생성해 던질 수 있다."),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="kotlin"><pre class="language-kotlin"><code class="language-kotlin"><span class="token annotation builtin">@Transactional</span>\n<span class="token keyword">fun</span> <span class="token function">scrapeAndSave</span><span class="token punctuation">(</span>userId<span class="token operator">:</span> Long<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">val</span> result <span class="token operator">=</span> <span class="token function">fetchAllHistories</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span>\n\n    result<span class="token punctuation">.</span><span class="token function">onFailure</span> <span class="token punctuation">{</span> error <span class="token operator">-></span>\n        <span class="token keyword">throw</span> <span class="token function">ScrapingException</span><span class="token punctuation">(</span>error<span class="token punctuation">.</span>msg<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">val</span> history <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">onSuccess</span> <span class="token punctuation">{</span> it <span class="token punctuation">}</span>\n\n    <span class="token comment">// DB에 저장</span>\n    <span class="token function">saveToDb</span><span class="token punctuation">(</span>userId<span class="token punctuation">,</span> history<span class="token punctuation">)</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"이런 방식의 제어 흐름을 일종의 선로라고 생각, ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">try catch</code>'}})," 없이 순차적으로만 개발하는 레일웨이 지향 프로그래밍",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Railway-Oriented Programming</code>'}}),"이라는 것도 있다.\n관심있는 사람들을 위해 잘 정리된 글 ",t.createElement(a.a,{href:"https://kciter.so/posts/railway-oriented-programming/",rel:"nofollow noopener noreferrer"},"링크"),"를 남긴다."),"\n",t.createElement(a.h1,{id:"5-결론"},t.createElement(a.a,{href:"#5-결론"},"5. 결론")),"\n",t.createElement(a.p,null,"예외 처리는 곧 프로그램의 신뢰를 다루는 문제다.\n신뢰가 근본적으로 깨진 상황(시스템 실패, DB 연결 오류 등)은 즉시 예외를 던져 빠르게 실패(fail-fast)하고,\n규칙이나 비즈니스 로직 상의 예상 가능한 오류(존재하지 않는 유저 ID, 잘못된 입력 값 등)는 값으로 명시적으로 전달하자."),"\n",t.createElement(a.p,null,"예외는 예외적으로만 던져야 의미가 있다.\n무의미한 커스텀 예외를 남발하는 대신, 실패의 이유를 명확하게 담을 수 있는 값 기반의 오류 처리를 고려하자.\n결국, 좋은 예외 처리는 개발자의 인지부하를 줄이고, 중요한 오류를 놓치지 않도록 돕는다."),"\n",t.createElement(a.p,null,"예외 처리에도 맥락이 필요하다. 상황에 따라 현명하게 선택하자."),"\n",t.createElement(a.h1,{id:"부록-그래도-나는-던지고-싶다--try-catch의-비용"},t.createElement(a.a,{href:"#부록-그래도-나는-던지고-싶다--try-catch의-비용"},"부록: 그래도 나는 던지고 싶다 – Try-Catch의 비용")),"\n",t.createElement(a.p,null,"그럼에도 불구하고 그냥 던지고 싶을 수 있다. 하지만 던지기 전에 한번쯤 비용이 궁금할 수도 있다.\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">try-catch</code>'}}),"의 비용을 분석하기 위해 ",t.createElement(a.a,{href:"https://velog.io/@aryumka/Kotlin-%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC-%EC%84%B1%EB%8A%A5-%EB%B9%84%EA%B5%90-Either-vs-Try-catch",rel:"nofollow noopener noreferrer"},"벤치마크 실험"),"을 진행했다."),"\n",t.createElement(a.p,null,"결론부터 말하자면 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">catch</code>'}})," 없는 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">throw</code>'}}),"는 거의 오버헤드가 없다.\n하지만 ",t.createElement(a.strong,null,t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">catch</code>'}}),"가 일어날 때 비용이 증가했는데, 정상 대비 throughput이 약 200배 가량 적었고, 반면 값을 사용하여 예외 처리한 경우 정상 대비 약 10배 가량 적은")," 것을 확인했다."),"\n",t.createElement(a.p,null,t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">try catch</code>'}}),"가 비싼 이유를 간단하게 정리하자면 아래의 두 가지 정도로 요약 가능하다."),"\n",t.createElement(a.ol,null,"\n",t.createElement(a.li,null,t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Throwable</code>'}}),"은 비싼 객체"),"\n"),"\n",t.createElement(a.ul,null,"\n",t.createElement(a.li,null,"특히 현재 스레드의 스택 정보를 기록하는 stackTrace 생성이 비쌈."),"\n",t.createElement(a.li,null,"stackTrace 로깅 등을 하게 되면 더욱 성능 저하"),"\n"),"\n",t.createElement(a.ol,{start:"2"},"\n",t.createElement(a.li,null,"JVM은 예외가 자주 발생하는 코드의 최적화를 포기함"),"\n"),"\n",t.createElement(a.ul,null,"\n",t.createElement(a.li,null,"메서드 인라이닝 하지 않음"),"\n",t.createElement(a.li,null,"무조건적 Heap 할당이 일어나고, 메모리 할당과 GC 비용 증가"),"\n",t.createElement(a.li,null,"기타 jvm 최적화에서 제외"),"\n"),"\n",t.createElement(a.p,null,t.createElement(a.strong,null,"성능이 중요한 코드에서는 특히 2번 경우를 조심할 필요가 있다.")),"\n",t.createElement(a.p,null,t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">과부하로 인한 에러 발생 증가</code>'}})," > ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">최적화 제외</code>'}})," > ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">성능 저하</code>'}})," > ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">부하 증가</code>'}})," > ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">과부하로 인한 에러 발생 증가</code>'}}),"> ... > ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">무한 반복</code>'}})),"\n",t.createElement(a.p,null,"부지불식간에 이런 악순환을 부르고 있는지도 모르기 때문이다."))}a.default=function(n){void 0===n&&(n={});const{wrapper:a}=Object.assign({},(0,e.R)(),n.components);return a?t.createElement(a,n,t.createElement(p,n)):p(n)}}}]);
//# sourceMappingURL=2b77100bec84de66f1e58555e0a397db9ba01de7-fa15cf1641127c64995f.js.map