{"componentChunkName":"component---src-templates-post-tsx-content-file-path-src-posts-2024-01-14-reinventing-big-integer-mdx","path":"/posts/reinventing-big-integer/","result":{"data":{"site":{"siteMetadata":{"title":"aryumka.me | devlog"}},"mdx":{"body":"\n개발 업계에서 바퀴를 다시 만들지 말라는 말을 흔히 들을 수 있다. 이는 보편적으로 오버엔지니어링을 하지말라는 의미로 볼 수 있지만 공부를 하는 측면에선 바퀴를 재발명해볼 가치가 있다. 평소 별 생각 없이 쓰던 것들을 분해하고 다시 구현해봄으로 CS 원리에 대한 이해와 지식을 얻을 수 있기 때문이다. \n\n여기에 더불어 기존의 것을 기반으로 새로운 것을 만들 수 있는 능력도 얻고 싶다는 기대로 이 시리즈를 시작해보려 한다.\n\n첫 시작은 [BigInteger](https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/math/BigInteger.html#multiply(java.math.BigInteger))로 정했다. 평소 회사에서 큰 수를 다루는 상황이 많아 BigInteger를 많이 사용하는 데 실제로 어떻게 동작하는지는 잘 몰랐기 때문에 이번 기회에 내부 동작 원리를 파악하고자 한다.\n\n## BigInteger란?\nLong 범위를 넘어가는 큰 범위의 수 연산을 할 수 있도록 지원하는 클래스이다. Java의 BigInteger는 기본적으로 Integer에서 제공하는 기본적 기능들을 지원한다. \n## 구현 과정\n### 구현할 메서드\n우선 클라이언트에게 필요할 대략적인 인터페이스를 먼저 README에 정의하며 인터페이스 설계를 시작했다.\n처음에는 사칙연산과 toString() 정도로 시작했지만 구현과정에서 자연스럽게 확장될 수밖에 없었다.\n> 처음 생각한 인터페이스\n> - String을 인자로 받는 기본 생성자\n> - Long, Int, String를 인자로 받는 팩토리\n> - 덧셈(plus)\n> - 뺄셈(minus)\n> - 곱셈(times)\n> - 나눗셈(div)\n> - 나머지(rem)\n> - toString()\n\n### 성능\n기본적으로 문자열을 연산하기 때문에 실제 숫자를 연산하는 것보다 훨씬 느리다. 구현한 주요기능들의 시간복잡도는 각 덧셈, 뺄셈은 O(n), 곱셈은 O(n^2), 나눗셈은 O(n^2) ~ O(n^3)다.\n\n### 테스트 작성과 코드 구현\n구현에 앞서 먼저 정의된 인터페이스를 사용하는 테스트들을 만들었다.\n컴파일은 되지만 실패하는 메서드를 만들 때 코틀린의 TODO() 메서드가 빛을 발했다.\n\nTDD 방식으로 개발을 하다보니 이런 케이스도 있지 않을까? 라는 생각이 계속 떠올랐다.\n\n예를 들어 minus를 만들면서 [빼기를 당하는 쪽이 더 작은 테스트 케이스](https://github.com/aryumka/BigInteger.kt/commit/ae00155354ebb98e9f41659ebe3a9947363dbc34\n)도 필요하지 않을까? 같은 의문이다.\n\n의문이 생기면 바로 테스트를 만들어 검증하며 진행했다. 통과하지 못하는 테스트들은 통과하게 만들었다.\n\n위와 같은 생각으로 빼기를 만들다보니 부호(sign)를 먼저 만들어야겠다는 생각이 들었다. 부호는 BigInteger 클래스 안의 Enum 클래스로 만들었다. \n부호를 만들다보니 '-123456789'같은 단항연산자(Unary Operator)도 필요하겠다는 생각까지 미치게 되었다. \n위와 같은 생각의 흐름을 모두 테스트로 작성 뒤 구현하였다.\n\n#### 코틀린의 연산자 오버로딩\n[코틀린에서는 연산자를 재정의할 수 있게 해준다.](https://kotlinlang.org/docs/operator-overloading.html)\n즉 직접 구현한 메서드를 a.plus(b)가 아닌 a + b로 사용할 수 있다.\n가능한 연산자는 크게 아래 두가지로 나뉜다.\n> **단항연산자(unary operator)**\n+, -, ++, -- 등 하나의 항에 적용되는 연산자\n**이항연산자(binary operator)**\n기본적인 산술연산자를 포함하여 포함(contains()), 인덱스, 비교(==, \\<, >)와 증감연산자(+=, -=) 등 두 개의 항에 적용되는 연산자\n\n처음에는 문자열로만 생성해 간단한 int 연산만을 테스트했으나 Long끼리 계산하는 경우 등 점점 복잡한 테스트케이스를 추가해갔다. \n구현하는 내내 빨간불을 초록불로 만드는 작업은 매우 매우 재밌고 희열감을 주는 작업이었다.\n\n최종적으로 완성된 인터페이스는 다음과 같았다.\n> - String을 인자로 받아 유효성 검사 뒤 부호(sign)도 함께 할당하는 생성자\n> - Long, Int, String를 인자로 받는 팩토리\n> - 덧셈(plus)\n> - 뺄셈(minus)\n> - 곱셈(times)\n> - 나눗셈(div)\n> - 나머지(rem)\n> - `+` (unaryPlus)\n> - `-` (unaryMinus)\n> - 절대값(abs)\n> - toString()\n> - compareTo()\n> - equals()\n\n## 배운 점\n- TDD를 적용, 다양한 케이스들을 즉시 검증하며 구현했다. **눈에 보이지 않는 불안감을 해결 가능하고 눈에 보이는 결과물로 만드는 게 중요하다고 느꼈다.**\n\n- String으로 계산하는 건 마치 손으로 써서 계산하는 과정을 코드로 구현하는 기분이었다. 검색해보니 이미 이를 부르는 grade-school(초등학교) 알고리즘이라는 공식적인 용어도 있었다.\n큰 수에 대해 시간복잡도를 개선할 수 있는 알고리즘도 있었다. 예를 들어 곱셈의 경우 대표적으로 [카라추바 알고리즘](https://ko.wikipedia.org/wiki/%EC%B9%B4%EB%9D%BC%EC%B6%94%EB%B0%94_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)이 있는데 이는 성능을 O(n^log(3)/log(2))까지 개선할 수 있는 분할, 정복 방법이라고 한다.\n\n## 결과\n완성된 BigInteger.kt는 아래와 같다.\n```kotlin\npackage aryumka.biginteger\n\nclass BigInteger(value: String) {\n  val integer: String\n  val sign: Sign\n\n  init {\n    if (value.isEmpty()) {\n      throw IllegalArgumentException(\"value must not be empty\")\n    }\n    if (!value.matches(Regex(\"^[+-]?[0-9_]+$\"))) {\n      throw IllegalArgumentException(\"value must be a number\")\n    }\n    if (value.startsWith(\"-\") || value.startsWith(\"+\")) {\n      this.integer = value.substring(1).replace(\"_\", \"\")\n      this.sign = if (value.startsWith(\"-\")) Sign.NEGATIVE else Sign.POSITIVE\n    } else {\n      this.integer = value.replace(\"_\", \"\")\n      this.sign = Sign.POSITIVE\n    }\n  }\n\n  // Factory methods\n  companion object {\n    fun of(value: String): BigInteger {\n      return BigInteger(value)\n    }\n\n    fun of(value: Int): BigInteger {\n      return BigInteger(value.toString())\n    }\n\n    fun of(value: Long): BigInteger {\n      return BigInteger(value.toString())\n    }\n  }\n\n  // Plus\n  private fun plus(other: String): BigInteger {\n    var result = \"\"\n    var carry = 0\n    var valueLength = this.integer.length - 1\n    var otherLength = other.length - 1\n\n    while (valueLength >= 0 || otherLength >= 0 || carry > 0) {\n      val valueDigit = if (valueLength >= 0) this.integer[valueLength] - '0' else 0\n      val otherDigit = if (otherLength >= 0) other[otherLength] - '0' else 0\n\n      val sum = valueDigit + otherDigit + carry\n\n      result += (sum % 10)\n      carry = sum / 10\n\n      valueLength--\n      otherLength--\n    }\n\n    return BigInteger(result.reversed())\n  }\n\n  operator fun plus(other: Int): BigInteger =\n    this.plus(other.toString())\n\n  operator fun plus(other: Long): BigInteger =\n    this.plus(other.toString())\n\n  operator fun plus(other: BigInteger): BigInteger =\n    this.plus(other.integer)\n\n\n\n  // Minus\n  operator fun minus(other: Int): BigInteger =\n    this.minus(other.toString())\n\n  operator fun minus(other: Long): BigInteger =\n    this.minus(other.toString())\n\n  operator fun minus(other: BigInteger): BigInteger =\n    this.minus(other.integer)\n\n  private fun minus(other: String): BigInteger {\n    var result = \"\"\n    var carry = 0\n\n    //find out which is bigger\n    var minuend = \"\"\n    var subtrahend = \"\"\n    var sign = \"\"\n\n    if (this < BigInteger(other)) {\n      minuend = other\n      subtrahend = this.integer\n      sign = \"-\"\n    } else if (this > BigInteger(other)) {\n      minuend = this.integer\n      subtrahend = other\n      sign = \"\"\n    } else {\n      return BigInteger(\"0\")\n    }\n\n    var minuLength = minuend.length - 1\n    var subLength = subtrahend.length - 1\n    while (minuLength >= 0 || subLength >= 0 || carry > 0) {\n      var minuDigit = if (minuLength >= 0) minuend[minuLength] - '0' else 0\n      val subDigit = if (subLength >= 0) subtrahend[subLength] - '0' else 0\n\n      if (minuDigit < subDigit) {\n        minuDigit += 10\n      }\n\n      val diff = minuDigit - subDigit - carry\n\n      carry = if (minuDigit >= 10) {\n        1\n      } else {\n        0\n      }\n\n      result += diff % 10\n\n      minuLength--\n      subLength--\n    }\n\n    return BigInteger(sign + result.reversed().trimStart('0'))\n  }\n\n  // Times\n  operator fun times(other: Int): BigInteger =\n    this.times(other.toString())\n\n  operator fun times(other: Long): BigInteger =\n    this.times(other.toString())\n\n  operator fun times(other: BigInteger): BigInteger =\n    this.times(other.toString())\n\n  private fun times(other: String): BigInteger {\n    var results = mutableListOf<String>()\n    var carry = 0\n    var valueLength = this.integer.length - 1\n    var otherLength = other.length - 1\n\n    var result = \"\"\n\n    for (i in otherLength downTo 0) {\n      val otherDigit = other[i] - '0'\n      for (j in valueLength downTo 0) {\n        val valueDigit = this.integer[j] - '0'\n\n        val sum = valueDigit * otherDigit + carry\n\n        result += (sum % 10)\n\n        carry = sum / 10\n      }\n      if (carry > 0) {\n        result += carry\n        carry = 0\n      }\n      results.add(result.reversed())\n      result = \"\"\n    }\n\n    return results.mapIndexed { index, s ->\n      s.padEnd(s.length + index, '0')\n    }.map { BigInteger(it) }.reduce { acc, bigInteger ->\n      acc + bigInteger\n    }\n  }\n  // Div\n  operator fun div(other: Int): BigInteger =\n    this.div(other.toString())\n\n  operator fun div(other: Long): BigInteger =\n    this.div(other.toString())\n\n  operator fun div(other: BigInteger): BigInteger =\n    this.div(other.toString())\n\n  private fun div(other: String): BigInteger {\n    var result = \"\"\n    var sign = if (this.sign == BigInteger(other).sign) \"\" else \"-\"\n    var remainder = BigInteger(this.integer)\n    val divisor = BigInteger(other)\n\n    if (other == \"0\") {\n      throw ArithmeticException(\"Division by zero\")\n    }\n\n    var count = 0\n    while (remainder >= divisor * of(count + 1)) {\n      count++\n    }\n    remainder -= divisor * of(count)\n    result += count\n\n    return BigInteger(sign + result)\n  }\n\n  // Rem\n  operator fun rem(other: Int): BigInteger =\n    this.rem(other.toString())\n\n  operator fun rem(other: Long): BigInteger =\n    this.rem(other.toString())\n\n  operator fun rem(other: BigInteger): BigInteger =\n    this.rem(other.toString())\n\n  private fun rem(other: String): BigInteger {\n    var sign = if (this.sign == BigInteger(other).sign) \"\" else \"-\"\n    var remainder = BigInteger(this.integer)\n    val divisor = BigInteger(other)\n\n    if (other == \"0\") {\n      throw ArithmeticException(\"Division by zero\")\n    }\n\n    var count = 0\n    while (remainder >= divisor * of(count + 1)) {\n      count++\n    }\n\n    remainder -= divisor * of(count)\n\n    return BigInteger(sign + remainder.integer)\n  }\n\n  // Unary\n  operator fun unaryPlus(): BigInteger =\n    this\n\n  operator fun unaryMinus(): BigInteger =\n    BigInteger(if (this.sign == Sign.POSITIVE) \"-${this.integer}\" else this.integer)\n\n  override fun equals(other: Any?): Boolean =\n    when (other) {\n      is BigInteger -> this.toString() == other.toString()\n      is String -> this.toString() == other\n      is Int -> this.toString() == other.toString()\n      is Long -> this.toString() == other.toString()\n      else -> false\n    }\n\n  operator fun compareTo(other: BigInteger): Int =\n    when {\n      this.sign == Sign.POSITIVE && other.sign == Sign.NEGATIVE -> 1\n      this.sign == Sign.NEGATIVE && other.sign == Sign.POSITIVE -> -1\n      this.sign == Sign.POSITIVE && other.sign == Sign.POSITIVE -> {\n        if (this.integer.length > other.integer.length) 1\n        else if (this.integer.length < other.integer.length) -1\n        else this.integer.compareTo(other.integer)\n      }\n      this.sign == Sign.NEGATIVE && other.sign == Sign.NEGATIVE -> {\n        if (this.integer.length > other.integer.length) -1\n        else if (this.integer.length < other.integer.length) 1\n        else this.integer.compareTo(other.integer)\n      }\n      else -> 0\n    }\n\n  override fun toString(): String = if (this.sign == Sign.POSITIVE) this.integer else \"-${this.integer}\"\n  fun abs(): BigInteger = BigInteger(this.integer)\n\n  enum class Sign {\n    POSITIVE, NEGATIVE\n  }\n}\n```\n테스트 코드를 포함한 [전체 코드 깃헙 저장소](https://github.com/aryumka/BigInteger.kt).\n\n## 아쉬운 점\n- 부호를 Enum이 아닌 정수로 표현할수 있지 않았을까? 곱셈, 나눗셈 연산을 할 때다 if문을 통해 비교한 코드가 조금 맘에 걸린다. 양수는 0, 음수는 1로 논리곱으로 구현하면 될 것 같은데. \n실제로도 컴퓨터에서 수를 표현 시 non-negative를 0으로 negative를 1로 표현하기도 한다고 한다.\n\n- 아규먼트만 바뀌는데 중복코드가 너무 많은 것 같다.\n시간을 내서 [data-driven test](https://wooooooak.github.io/%EB%B2%88%EC%97%AD%ED%95%98%EB%A9%B0%20%EA%B3%B5%EB%B6%80%ED%95%98%EA%B8%B0/2021/01/04/kotest_data_driven_testing/)로 리팩토링해야겠다. \n\n- 여유가 생기면 성능 개선 후 power나 Augmented assignment도 구현해야겠다.\n","tableOfContents":{"items":[{"url":"#biginteger란","title":"BigInteger란?"},{"url":"#구현-과정","title":"구현 과정","items":[{"url":"#구현할-메서드","title":"구현할 메서드"},{"url":"#성능","title":"성능"},{"url":"#테스트-작성과-코드-구현","title":"테스트 작성과 코드 구현","items":[{"url":"#코틀린의-연산자-오버로딩","title":"코틀린의 연산자 오버로딩"}]}]},{"url":"#배운-점","title":"배운 점"},{"url":"#결과","title":"결과"},{"url":"#아쉬운-점","title":"아쉬운 점"}]},"excerpt":"개발 업계에서 바퀴를 다시 만들지 말라는 말을 흔히 들을 수 있다. 이는 보편적으로 오버엔지니어링을 하지말라는 의미로 볼 수 있지만 공부를 하는 측면에선 바퀴를 재발명해볼 가치가 있다. 평소 별 생각 없이 쓰던 것들을 분해하고 다시 구현해봄으로 CS…","fields":{"slug":"/posts/reinventing-big-integer","date":"2024-01-14"},"frontmatter":{"title":"[바퀴의 재발명] BigInteger","categories":"dev","tags":["Kotlin","BigInteger"],"image":"/images/og.png","comments":true,"draft":false}},"allMdx":{"edges":[{"node":{"fields":{"date":"2023-03-18","slug":"/posts/spring-boot-tomcat"},"frontmatter":{"title":"스프링부트의 톰캣 실행","image":"https://velog.velcdn.com/images/aryumka/post/5b95b704-67df-48b2-bdde-620b629f10ae/image.png"}}},{"node":{"fields":{"date":"2023-04-10","slug":"/posts/jsoup-html-parser"},"frontmatter":{"title":"Jsoup을 이용하여 HTML Parser 만들기","image":"https://velog.velcdn.com/images/aryumka/post/251571e0-9d24-4ef3-aa0d-f4d8654212c3/image.png"}}},{"node":{"fields":{"date":"2023-12-24","slug":"/posts/properties-vs-yaml"},"frontmatter":{"title":"Properties vs YAML - 스프링부트 외부설정","image":"https://velog.velcdn.com/images/aryumka/post/9173f985-e7b4-4d03-9996-93a08c517845/image.png"}}},{"node":{"fields":{"date":"2023-12-25","slug":"/posts/mysql-date-type"},"frontmatter":{"title":"MySQL date 타입에 대하여: varchar(8)과의 비교를 중점으로","image":"https://velog.velcdn.com/images/aryumka/post/e84fde44-1e6e-436e-bf62-6749c6ca1845/image.png"}}},{"node":{"fields":{"date":"2023-12-28","slug":"/posts/holiday-til-1"},"frontmatter":{"title":"[연휴개발TIL] DAY1 - kotiln + kotest + Spring Data JPA","image":"https://velog.velcdn.com/images/aryumka/post/9173f985-e7b4-4d03-9996-93a08c517845/image.png"}}},{"node":{"fields":{"date":"2023-12-29","slug":"/posts/holiday-til-2"},"frontmatter":{"title":"[연휴개발TIL] DAY2 - Github Action + Mockk","image":"https://velog.velcdn.com/images/aryumka/post/6e45e3ee-1592-433f-a0e8-e69b23738caf/image.png"}}},{"node":{"fields":{"date":"2023-12-31","slug":"/posts/holiday-til-3"},"frontmatter":{"title":"[연휴개발TIL] DAY3","image":"https://velog.velcdn.com/images/aryumka/post/0c169fc0-5d98-4cd2-9d50-04672ebc9d84/image.png"}}},{"node":{"fields":{"date":"2024-01-02","slug":"/posts/holiday-til-4"},"frontmatter":{"title":"[연휴개발TIL] DAY3","image":"https://velog.velcdn.com/images/aryumka/post/3e146a87-d66d-4ff3-953f-9da5e5c92441/image.png"}}},{"node":{"fields":{"date":"2024-01-03","slug":"/posts/github-actions"},"frontmatter":{"title":"GitHub Actions 정리","image":"https://velog.velcdn.com/images/aryumka/post/07ec2107-424c-4a8c-9c11-005508653ee2/image.png"}}},{"node":{"fields":{"date":"2024-01-07","slug":"/posts/til-practice-tdd"},"frontmatter":{"title":"[TIL] README, 테스트 작성과 코드 구현","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-01-04","slug":"/posts/til-aws-elastic-ip-docker"},"frontmatter":{"title":"[TIL] aws 탄력적 ip + Docker 사용해보기","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-01-10","slug":"/posts/til-java-static-block-kotlin-companion-object"},"frontmatter":{"title":"[TIL] Java의 static block vs Kotlin의 companion object","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-01-09","slug":"/posts/til-kotlin-binary"},"frontmatter":{"title":"[TIL] 코틀린 이진수 변환","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-01-14","slug":"/posts/reinventing-big-integer"},"frontmatter":{"title":"[바퀴의 재발명] BigInteger","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-01-15","slug":"/posts/til-resource"},"frontmatter":{"title":"[TIL] 리소스 위치 참조 시 / 쓰지 않기","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-01-16","slug":"/posts/til-gradle-build-error"},"frontmatter":{"title":"[TIL] 인텔리제이 gradle 빌드 오류(feat. JDK 버젼 호환)","image":"https://velog.velcdn.com/images/aryumka/post/14ac2014-f469-4a23-b3cd-d95c2e912efe/image.png"}}},{"node":{"fields":{"date":"2024-01-17","slug":"/posts/til-kotlin-inline-reflection"},"frontmatter":{"title":"[TIL] 코틀린 inline, reflection","image":"https://velog.velcdn.com/images/aryumka/post/14ac2014-f469-4a23-b3cd-d95c2e912efe/image.png"}}},{"node":{"fields":{"date":"2024-01-24","slug":"/posts/query-if-null-return"},"frontmatter":{"title":"[TIL] 쿼리로 피벗 시 if 함수에서 의도된 Null 리턴","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-01-25","slug":"/posts/kotlin-reflection"},"frontmatter":{"title":"[JVM 톺아보기] 코틀린의 리플렉션(Reflection)","image":"https://velog.velcdn.com/images/aryumka/post/c9d716a4-0eef-4663-90e1-69631029d564/image.png"}}},{"node":{"fields":{"date":"2024-02-01","slug":"/posts/jvm-permgen"},"frontmatter":{"title":"[JVM 톺아보기] JVM의 메서드 영역 (feat. PermGen space)","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-02-06","slug":"/posts/real-mysql"},"frontmatter":{"title":"[TIL] Real MySQL","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-02-07","slug":"/posts/til-kotlin-sort"},"frontmatter":{"title":"[TIL] Kotlin - sortedWith과 compareBy를 이용한 다중조건 정렬","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-02-18","slug":"/posts/reinventing-di-framework"},"frontmatter":{"title":"[바퀴의 재발명] DI 프레임워크 직접 만들어보기","image":"https://velog.velcdn.com/images/aryumka/post/94394c32-2228-4acb-8be0-a82e13fa78a1/image.png"}}},{"node":{"fields":{"date":"2024-03-03","slug":"/posts/functional-exception"},"frontmatter":{"title":"[TIL] 예외를 함수로 처리","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-03-02","slug":"/posts/til-kotlin-jpa-test"},"frontmatter":{"title":"[TIL] Kotlin + JPA + Kotest + H2 DB","image":"https://velog.velcdn.com/images/aryumka/post/af776ead-b672-4d57-80bb-fe6fac180764/image.png"}}},{"node":{"fields":{"date":"2024-04-03","slug":"/posts/til-json"},"frontmatter":{"title":"[TIL] JSON 유효하지 않은 문자열 제거","image":"https://velog.velcdn.com/images/aryumka/post/ed5979e8-49ef-4be8-9a1c-5b9203d2574f/image.png"}}},{"node":{"fields":{"date":"2024-04-22","slug":"/posts/rabbitmq-seven-patterns"},"frontmatter":{"title":"RabbitMQ 7가지 설계 패턴 (with Spring AMQP tutorial)","image":"https://velog.velcdn.com/images/aryumka/post/f2266935-81ba-47b8-9b4f-910d28c1aaef/image.png"}}},{"node":{"fields":{"date":"2024-05-04","slug":"/posts/til-test-container"},"frontmatter":{"title":"[TIL] Test Container","image":"https://velog.velcdn.com/images/aryumka/post/9fcbd346-bd6e-4097-bce9-b7c9468b5cfc/image.png"}}},{"node":{"fields":{"date":"2024-05-05","slug":"/posts/til-axon-framework"},"frontmatter":{"title":"[TIL] Axon Framework - Token","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-05-12","slug":"/posts/kafka-axon-eventsourcing"},"frontmatter":{"title":"Kafka와 Axon Framework를 이용한 이벤트 소싱 - 1","image":"/images/og.png"}}},{"node":{"fields":{"date":"2025-04-15","slug":"/posts/should-exception-be-thrown"},"frontmatter":{"title":"예외는 던져져야 할까?","image":"https://velog.velcdn.com/images/aryumka/post/c2ff7c02-dbbb-4ca1-913c-b8c040251b78/image.png"}}}]}},"pageContext":{"slug":"/posts/reinventing-big-integer","series":{"title":"바퀴의 재발명","items":[{"title":"[바퀴의 재발명] BigInteger","url":"/posts/reinventing-big-integer"},{"title":"[바퀴의 재발명] DI 프레임워크 직접 만들어보기","url":"/posts/reinventing-di-framework"}]},"frontmatter":{"title":"[바퀴의 재발명] BigInteger","categories":"dev","tags":["Kotlin","BigInteger"],"series":"바퀴의 재발명","cover":"","image":"/images/og.png","comments":true,"draft":false,"hide":false}}},"staticQueryHashes":["595849736","63159454"],"slicesMap":{}}