{"componentChunkName":"component---src-templates-post-tsx-content-file-path-src-posts-2024-02-18-reinventing-di-framework-mdx","path":"/posts/reinventing-di-framework/","result":{"data":{"site":{"siteMetadata":{"title":"aryumka.me | devlog"}},"mdx":{"body":"\nimport Image from '@components/Image';\n\n# DI는 왜 필요할까\n## 개요\n\n`DI`는 의존관계 주입(Dependency Injection)의 줄임말으로 객체지향 디자인패턴 중 하나이다. \n객체지향 프로그램 내 객체들은 다양한 생명주기를 가지며 서로 상호작용하고 다양한 형태의 의존관계를 갖게 된다. \n\n> **Dependency?**\n의존관계 혹은 의존성. Dependency를 직역하면 의존성이기도 하고 흔히 이렇게 불리고 있지만 의존관계라는 표현이 더 의미전달에 맞다고 생각하여 (토비의 스프링 참조) 의존관계로 표현한다.\n\n\n코드를 예시로 살펴보자. 아래와 같은 프로그램이 있을 때,\n```java\nclass Dog extends Animal {\n\tToy toy;\n    public Dog(Toy toy) {\n    \tthis.toy = toy;\n    }\n}\n\ninterface Toy {\n\t/*...*/\n}\n\nclass Doll implements Toy {\n\t/*...*/\n}\n```\n`Dog`는 `Toy`에 의존관계를 갖고있다. 이제 `Doll`객체를 받아 `Dog`객체를 생성하려면 어떻게 해야 할까?\n\n```java\nToy doll = new Doll();\nDog cuteDog = new Dog(doll);\n```\n`Toy`객체를 직접 생성, `Dog`객체가 생성될 때 직접적으로 `Doll`와 의존관계를 맺을수도 있고\n\n```java\n/* 외부 모듈 Injector에 의해 의존관계 주입 */\n/* Config에 Dog와 Doll의 의존관계가 미리 설정되어 있다고 가정한다.*/\nInjector injector = new Injector(Config);\nDog cuteDog = injector.get(Dog.class)\n```\n\n외부모듈에 의해 미리 생성된 의존관계를 공급받아 객체를 생성하기도 한다. 후자와 같은 형태를 `DI` 패턴이라고 한다.\n\n그림으로 나타내면 아래와 같다.\n\n<Image src=\"https://velog.velcdn.com/images/aryumka/post/7f996a48-7da4-4a94-acd1-336eae84403e/image.png\" />\n<Image src=\"https://velog.velcdn.com/images/aryumka/post/0dbb415c-8d11-4398-bb95-7ffec7122e44/image.png\" />\n\n의존관계 **주입**이라는 말에서 알 수 있듯 DI 패턴에서는 객체 **외부의 다른 객체 또는 모듈**이 객체 생성 및 의존관계 설정을 담당한다. \n**마치 블록을 조립할 때 블록이 아닌 조립하는 사람이 완성된 모양을 결정하는 것처럼 말이다.** \n\n## DIP(Dependency Inversion Principle): 의존관계 역전 원칙\n\n객체가 자신의 의존관계를 직접 설정하지 않도록 하는 이유가 뭘까?\n객체지향 원칙인 **`SOLID`**를 살펴보자.\n> **S**: 단일 책임 원칙 (Single responsibility principle) - 한 클래스는 하나의 책임만 가져야 한다.\n**O**: 개방-폐쇄 원칙 (Open/closed principle) - “소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.”\n**L**: 리스코프 치환 원칙 (Liskov substitution principle) - “프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.” 계약에 의한 설계를 참고하라.\n**I**: 인터페이스 분리 원칙 (Interface segregation principle) - “특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.”\n**D**: 의존관계 역전 원칙 (Dependency inversion principle) - 프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.”\n[출처: 위키피디아](https://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84))\n\n이 중 `의존관계 역전 원칙`을 실행하기 위한 방법 중 하나가 DI 패턴이다.\n\n만약 위의 예시 코드에서 `Dog`가 주입받는 `Toy` 객체가 `Doll`이 아니라 `Bone`객체로 바뀐다면 어떻게 될까? 직접 의존관계를 설정한 프로그램이라면 아마도 아래와 같이 구체적 코드를 변경해야 할 것이다.\n```java\nToy bone = new Bone();\nDog cuteDog = new Dog(bone);\n```\n자연스럽게 개방-폐쇄 원칙을 위반하게 된다.\n\n반면 DI 패턴이 적용된 구현코드는 수정이 필요없다. 이미 Dog 타입의 객체는 Toy 타입의 인터페이스에 의존하고 있고 Bone과 Doll은 모두 Toy를 구현하고 있기 때문이다. \n고수준 모듈에서 새로운 구현체를 주입하도록 설정`Config`만 변경해주면 된다. \n\n이런 의존관계를 설정해주는 고수준 모듈을 손쉽게 사용하기 위해 DI 프레임워크를 사용한다.\n\n# DI 프레임워크\n\n<Image src=\"https://velog.velcdn.com/images/aryumka/post/7f306d31-a0c8-40e8-91b5-6c791b188a07/image.png\" />\n\n객체지향 패러다임을 포함하는 많은 프레임워크들에서 DI를 제공하고 있다.\n\n대표주자로는 자바(또는 코틀린) 기반 어플리케이션 프레임워크인 `Spring`의 `IoC Container`가 있다. 자바, 안드로이드, 코틀린 네이티브, 코틀린 멀티플랫폼 등 다양한 환경을 지원하는  DI 프레임워크인 `Koin`, `Javascript`에서는 `nest.js` 등이 DI 프레임워크를 제공한다. \n이러한 프레임워크들에서는 메타데이터를 이용, 의존관계를 주입하거나 객체 생성, 초기화, 사용(조회 등), 객체 소멸 같은 객체의 생명주기를 관리하는 역할을 한다.\n\n이러한 프레임워크들의 동작 원리를 이해하기 위해 `Kontainer`라는 간단한 DI 컨테이너를 만들어보았다.\n## Kontainer 소개\n`Kontainer`는 코틀린으로 작성했다. \nhttps://github.com/aryumka/kontainer\n\n메이븐 중앙저장소에 배포되어있다.\n\n상세 내용은 다음과 같다.\n### 1. 컨테이너 구조\n컨테이너는 코틀린의 `object` 클래스를 이용, 싱글톤으로 구현했다. \n컨테이너가 갖는 필드들은 다음과 같다.\n- 빈들의 메타데이터가 저장되는 `registeredBean`\n- 생성된 빈들이 저장되는 `createdBean`\n- 의존관계 그래프인 `dependencyGraph`\n- 의존관계 그래프의 간선을 저장한 `edges`\n- 각 빈들의 루트 빈의 정보를 저장하는 `rootIndices`, `rootIdxMap` \n>여기서 빈은 프레임워크에 의해 관리되는 컴포넌트(인스턴스)이다.\n** 컴포넌트와 모듈의 차이: 컴포넌트는 런타임에 동적으로, 모듈은 컴파일 타임에 정적으로 존재한다.\n### 2. 빈 메타데이터 등록\n먼저 `Kontainer`에게 어떤 인스턴스를 생성해야 하는지, 각 인스턴스들의 의존관계가 어떻게 되는지 등을 알려줘야 한다. 즉 데이터(객체)에 대한 데이터, **메타데이터**를 제공해야 한다.\n프로그램을 실행하는 `main` 함수에서 아래와 같이 빈을 등록한다.\n```kotlin\nval kontainer = Kontainer()\nkontainer.register(HelloService::class)\n```\n`register` 함수는 코틀린의 `Reflection` API(리플렉션 설명)를 이용하여 구현하였다.\n```kotlin\nfun register(kClass: KClass<*>) {\n\tregisteredBean.add(kClass)\n\trootIdxMap[kClass] = registeredBean.size - 1\n}\n```\n빈을 등록하면 `registeredBean`에 해당 객체의 메타데이터 [KClass](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/)가 추가된다. \n```kotlin\nprivate val registeredBean = mutableListOf<KClass<*>>() //registeredBean: [class context.HelloService]\n```\n등록과 동시에 해당 빈의 루트를 저장할 `rootIdxMap`에 빈이 추가되는 순서대로 인덱스가 부여된다. 이 인덱스는 의존성 그래프를 그릴 때 사용된다.\n\n`Kontainer`에서는 클래스, 생성자, 필드, 메서드 등 객체로써 메타데이터만 저장하지만 일반적인 DI 프레임워크에는 더 넓은 범위의 설정정보가 필요하다.\n\n컴포넌트로써의 속성, 즉 런타임에 프레임워크 내에서 어떻게 사용되는지에 대한 정보도 필요하기 때문이다. 빈의 생명주기를 결정하는 스코프, 인터페이스 사용 시 구현체 선택 정보 등이 이에 해당한다.\n\n>참고로 `Spring`에서는 프로그램 내 코드 뿐만이 아닌 다양한 외부 설정으로 빈의 메타데이터를 제공할 수 있다.\n`.xml` 또는 `.properties`와 같은 설정파일이나 `Groovy` 스크립트 파일, 코드에 삽입하여 런타임에 설정되도록 하는 `애너테이션` 등등으로 프로그램 구현 로직과 분리된 다양하고 높은 수준의 추상화가 가능하다. 각 설정마다 다른 `ApplicationContext` 구현체로 구현된다.\n\n### 3. 빈 의존관계 설정 및 주입\n`Kontainer`에서는 2에서 등록된 각 빈의 **기본 생성자 파라미터**를 통해 의존관계를 파악하며 이를 의존관계 그래프 `dependencyGraph`로 나타낸다. \n```kotlin\nprivate val dependencyGraph = mutableMapOf<KClass<*>, List<KClass<*>>>()\n```\n이후 생성에 필요한 의존관계를 이 `dependencyGraph`에서 찾아 생성과 동시에 주입한다. \n\n예를 들어 아래와 같은 의존관계를 갖고 있는 클래스들을 등록 `register`했다고 가정하자.\n```kotlin\nclass E\nclass B\nclass C\nclass D(val e: E)\nclass A(\n\tval b: B,\n    val c: C,\n    val d: D\n)\nclass G\nclass F(val g: G)\n\nval kontainer = Kontainer\n\nkontainer.register(A::class)\nkontainer.register(B::class)\nkontainer.register(C::class)\nkontainer.register(D::class)\nkontainer.register(E::class)\nkontainer.register(F::class)\nkontainer.register(G::class)\n```\n\n다이어그램으로 표현하면 다음과 같다.\n\n<Image src=\"https://velog.velcdn.com/images/aryumka/post/fdeb4985-a8bf-4ca8-9754-1b2f2520d9a5/image.png\" />\n\n`registeredBean`의 메타데이터를 참조하여 기본 생성자 파라미터를 가져와 의존관계 그래프 `dependencyGraph`와 간선정보 `edges`를 세팅한다.\n```kotlin\nprivate fun setDependencyGraph() {\n\tfor (bean in registeredBean) {\n    \tval constructor = bean.primaryConstructor!!\n        val parameters = constructor.parameters\n        val parameterTypes = parameters.map { it.type.classifier as KClass<*> }\n        dependencyGraph[bean] = parameterTypes\n        \n        for (parameter in parameterTypes) {\n        \tedges.add(Pair(bean, parameter))\n        }\n\t}\n}\n```\n\n그리고 의존관계 그래프를 탐색하여 순환참조가 발생하는지 확인 한다.\n이를 위해 의존관계에서 가장 상단에 있는 루트 노드를 확인한다.\n먼저 아래와 같이 자기 자신을 루트 노드로 초기화 해준 후\n```kotlin\nprivate fun initRootIndices() {\n\trootIndices = IntArray(registeredBean.size)\n\tfor (i in rootIndices.indices) rootIndices[i] = i\n}\n```\n간선 정보를 이용, 빈 등록 시 세팅해주었던 `rootIdxMap`을 함께 이용하여 `UnionFind` 알고리즘을 통해 순환 참조가 있는지 파악한다.\n```kotlin\nprivate fun unionFind() {\n  for (edge in edges) {\n    val (parent, child) = edge\n    val parentIndex = rootIdxMap[parent]!!\n    val childIndex = rootIdxMap[child]!!\n    \n    for (i in rootIndices.indices) {\n      if (rootIndices[i] == childIndex) {\n\t      if (rootIndices[i] == rootIndices[parentIndex]) {\n      \t\tthrow CircularDependencyException(\"Circular Dependency for $parent and $child\")\n    \t  }\n      rootIndices[i] = rootIndices[parentIndex]\n      }\n    }\n  }\n}\n```\n순환참조가 탐지되지 않았다면 의존관계 그래프에 담겨있는 메타데이터를 참조해 빈을 생성하고 주입한다.\n```kotlin\nprivate fun createBeans() {\n  for (i in rootIndices.indices) {\n    if (rootIndices[i] == i) {\n\t    createBean(registeredBean[i], dependencyGraph[registeredBean[i]]!!)\n    }\n  }\n}\n\n//재귀적으로 탐색하여 아무 객체에도 의존하지 않는 것부터 생성\nprivate fun createBean(parent: KClass<*>, children:List<KClass<*>>) {\n\tfor (i in children.indices) {\n\t\tif (!createdBean.containsKey(children[i].simpleName!!) || createdBean[children[i].simpleName!!] == null) {\n\t\t\tcreateBean(children[i], dependencyGraph[children[i]]!!)\n\t\t}\n\t}\n\tcreatedBean[parent.simpleName!!] = parent.primaryConstructor!!.call(*children.map { createdBean[it.simpleName!!] }.toTypedArray())\n}\n\n```\n\n일반적으로 사용되는 DI 프레임워크들의 경우 기본생성자 외에도 다양한 방법의 DI가 가능하다.\n\n생성자가 여러 개일 때 DI 컨테이너가 어떤 생성자를 사용해야 하는지 알려줄 수도 있으며 생성자 주입이 아닌 생성 이후 `setter` 메서드 등으로 필드 주입을 할수도 있다. \n\n>필드 주입의 경우 생성 시점과 주입 시점이 다르다. 주입시점에 이미 컨테이너 자신이 생성한 빈을 가져와 주입하며 이 때 주입될 빈이 생성되지 않았다면  `NullPointerException`가 발생한다. 순환참조 관계를 미리 알 수 없으므로 어플리케이션 실행 중 순환참조 문제가 발생할 수도 있다. `Spring`의 경우 공식적으로 생성자 주입을 권장하고 있다.\n\n### 4. 생명주기 관리\n`Kontainer`에서는 `start` 메서드를 통해 모든 빈을 일괄적으로 생성하고 `end` 메서드를 통해 모든 빈을 삭제한다. 이외의 별도의 생명주기 관리는 없다.\n\n일반적인 DI 프레임워크들에서는 단순한 객체 생성 및 의존관계 주입뿐만이 아닌 초기화 또는 파괴(destruct)와 그에 따른 콜백 실행 등 전체 생명주기를 관리한다. \n\n이러한 생명주기는 각 빈의 스코프에 따라 달라질 수 있다.\n`Kontainer`에서는 오직 싱글톤 인스턴스만 등록할 수 있지만 일반적인 프레임워크들에서는 객체의 목적에 따라 다양한 스코프의 빈을 지원하기도 한다. \n> `Spring`의 경우 singleton, prototype, request, session, application, websocket [총 6개의 스코프](https://docs.spring.io/spring-framework/reference/core/beans/factory-scopes.html)를 지원한다.\n> `Koin`의 경우 [커스텀 스코프](https://insert-koin.io/docs/reference/koin-core/scopes)를 만들어서 사용할 수 있다.\n\n### 5. 빈 사용\n`Kontainer`에서는 컨테이너 생성 후 등록한 빈을 아래와 같이 가져와 사용한다.\n```kotlin\nval kontainer = Kontainer\nkontainer.register(HelloService::class)\nkontainer.register(HelloDao::class)\nkontainer.start()\n\nval bean = kontainer.getBean<HelloService>(\"HelloService\")\n```\n\n## 보완하고 싶은 점\n- 빈의 이름을 지정하는 `Qualifier`, 스코프 등 빈에 대한 상세한 설정이 필요하다.\n- 빈 설정을 네이티브 코드가 아닌 다양한 방법으로 지원할 수 있다면 좋겠다. 특히 애너테이션을 통한 빈 설정이 최우선순위.\n- 필드 주입 등 다양한 DI 방법을 추가하고 싶다.\n- 추가된 다양한 DI 방법 및 설정에 따라 추상화된 구조를 만들어야 한다.\n- 컨테이너 내 역할에 따른 객체지향적 설계가 필요하다. 현재는 모든 기능이 단일 클래스 안에 구현되어 있다. \n- 적절한 모듈화가 이루어져야 한다. 예를 들어 빈 등록 같은 설정을 `main`함수에서 호출하는 것보다는 별도의 설정파일에서 설정, `main`에서는 이를 참조만 하는 것이 바람직하다.\n```kotlin\n//koin api 호출 예시\nfun main(vararg args : String){\n    // Start Koin\n    startKoin {\n        modules(myModule)\n    }\n\n    // Create MyComponent instance and inject from Koin container\n    MyComponent()\n}\n\nclass MyService\n// 모듈 설정\nval myModule = module {\n    // Define a singleton for MyService\n    single { MyService() }\n}\n```\n- `getBean` 함수에서 타입 파라미터 이외에도 `name: String`을 넣어줘야 한다. 중복적이고 불필요한 코드이므로 개선이 필요하다.\n\n# 마치며\n\n스프링을 처음 배웠을 때의 기억이 아직도 생생하다. \n이게 뭔지 또 이걸 왜 써야하는지 머릿속에 물음표만이 가득했다. \n\n이후 실무에서도 숨쉬듯 익숙하게 스프링을 써오면서도 IoC 컨테이너의 동작원리나 근본적인 존재 이유에 대해 생각하면 늘 먹구름이 낀 것처럼 흐릿했다.\n\n직접 DI 컨테이너를 만들어 보고 글로 정리하고 보니 이제야 긴 숙제를 마친 기분이다.\n\n텍스트로만 존재했던 스프링에 대한 파편화된 지식이 이번 경험을 통해 각자의 맥락을 찾아 하나로 연결되어 자리잡을 수 있었다.\n\n당연한 말이지만 세상에 당연히 되는 건 없다. \n우리가 사용하는 모든 소프트웨어는 마법같이 태어나 존재하는 것이 아니라 우리가 이해할 수 있는 논리와 설계로 이루어진다. 자료구조와 알고리즘이 그 뼈대가 된다는 것도 이번 기회를 통해 직접 피부로 느낄 수 있었다. \n\n다음 바퀴를 만들 때는 또 무엇을 배울 수 있을지 기대된다.\n\n\n","tableOfContents":{"items":[{"url":"#di는-왜-필요할까","title":"DI는 왜 필요할까","items":[{"url":"#개요","title":"개요"},{"url":"#dipdependency-inversion-principle-의존관계-역전-원칙","title":"DIP(Dependency Inversion Principle): 의존관계 역전 원칙"}]},{"url":"#di-프레임워크","title":"DI 프레임워크","items":[{"url":"#kontainer-소개","title":"Kontainer 소개","items":[{"url":"#1-컨테이너-구조","title":"1. 컨테이너 구조"},{"url":"#2-빈-메타데이터-등록","title":"2. 빈 메타데이터 등록"},{"url":"#3-빈-의존관계-설정-및-주입","title":"3. 빈 의존관계 설정 및 주입"},{"url":"#4-생명주기-관리","title":"4. 생명주기 관리"},{"url":"#5-빈-사용","title":"5. 빈 사용"}]},{"url":"#보완하고-싶은-점","title":"보완하고 싶은 점"}]},{"url":"#마치며","title":"마치며"}]},"excerpt":"개요 는 의존관계 주입(Dependency Injection)의 줄임말으로 객체지향 디자인패턴 중 하나이다. 객체지향 프로그램 내 객체들은 다양한 생명주기를 가지며 서로 상호작용하고 다양한 형태의 의존관계를 갖게 된다.\n\nDependency? 의존…","fields":{"slug":"/posts/reinventing-di-framework","date":"2024-02-18"},"frontmatter":{"title":"[바퀴의 재발명] DI 프레임워크 직접 만들어보기","categories":"dev","tags":["Kotlin","DI"],"image":"https://velog.velcdn.com/images/aryumka/post/94394c32-2228-4acb-8be0-a82e13fa78a1/image.png","comments":true,"draft":false}},"allMdx":{"edges":[{"node":{"fields":{"date":"2023-03-18","slug":"/posts/spring-boot-tomcat"},"frontmatter":{"title":"스프링부트의 톰캣 실행","image":"https://velog.velcdn.com/images/aryumka/post/5b95b704-67df-48b2-bdde-620b629f10ae/image.png"}}},{"node":{"fields":{"date":"2023-04-10","slug":"/posts/jsoup-html-parser"},"frontmatter":{"title":"Jsoup을 이용하여 HTML Parser 만들기","image":"https://velog.velcdn.com/images/aryumka/post/251571e0-9d24-4ef3-aa0d-f4d8654212c3/image.png"}}},{"node":{"fields":{"date":"2023-12-24","slug":"/posts/properties-vs-yaml"},"frontmatter":{"title":"Properties vs YAML - 스프링부트 외부설정","image":"https://velog.velcdn.com/images/aryumka/post/9173f985-e7b4-4d03-9996-93a08c517845/image.png"}}},{"node":{"fields":{"date":"2023-12-25","slug":"/posts/mysql-date-type"},"frontmatter":{"title":"MySQL date 타입에 대하여: varchar(8)과의 비교를 중점으로","image":"https://velog.velcdn.com/images/aryumka/post/e84fde44-1e6e-436e-bf62-6749c6ca1845/image.png"}}},{"node":{"fields":{"date":"2023-12-28","slug":"/posts/holiday-til-1"},"frontmatter":{"title":"[연휴개발TIL] DAY1 - kotiln + kotest + Spring Data JPA","image":"https://velog.velcdn.com/images/aryumka/post/9173f985-e7b4-4d03-9996-93a08c517845/image.png"}}},{"node":{"fields":{"date":"2023-12-29","slug":"/posts/holiday-til-2"},"frontmatter":{"title":"[연휴개발TIL] DAY2 - Github Action + Mockk","image":"https://velog.velcdn.com/images/aryumka/post/6e45e3ee-1592-433f-a0e8-e69b23738caf/image.png"}}},{"node":{"fields":{"date":"2023-12-31","slug":"/posts/holiday-til-3"},"frontmatter":{"title":"[연휴개발TIL] DAY3","image":"https://velog.velcdn.com/images/aryumka/post/0c169fc0-5d98-4cd2-9d50-04672ebc9d84/image.png"}}},{"node":{"fields":{"date":"2024-01-02","slug":"/posts/holiday-til-4"},"frontmatter":{"title":"[연휴개발TIL] DAY3","image":"https://velog.velcdn.com/images/aryumka/post/3e146a87-d66d-4ff3-953f-9da5e5c92441/image.png"}}},{"node":{"fields":{"date":"2024-01-03","slug":"/posts/github-actions"},"frontmatter":{"title":"GitHub Actions 정리","image":"https://velog.velcdn.com/images/aryumka/post/07ec2107-424c-4a8c-9c11-005508653ee2/image.png"}}},{"node":{"fields":{"date":"2024-01-04","slug":"/posts/til-aws-elastic-ip-docker"},"frontmatter":{"title":"[TIL] aws 탄력적 ip + Docker 사용해보기","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-01-07","slug":"/posts/til-practice-tdd"},"frontmatter":{"title":"[TIL] README, 테스트 작성과 코드 구현","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-01-09","slug":"/posts/til-kotlin-binary"},"frontmatter":{"title":"[TIL] 코틀린 이진수 변환","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-01-10","slug":"/posts/til-java-static-block-kotlin-companion-object"},"frontmatter":{"title":"[TIL] Java의 static block vs Kotlin의 companion object","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-01-14","slug":"/posts/reinventing-big-integer"},"frontmatter":{"title":"[바퀴의 재발명] BigInteger","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-01-16","slug":"/posts/til-gradle-build-error"},"frontmatter":{"title":"[TIL] 인텔리제이 gradle 빌드 오류(feat. JDK 버젼 호환)","image":"https://velog.velcdn.com/images/aryumka/post/14ac2014-f469-4a23-b3cd-d95c2e912efe/image.png"}}},{"node":{"fields":{"date":"2024-01-15","slug":"/posts/til-resource"},"frontmatter":{"title":"[TIL] 리소스 위치 참조 시 / 쓰지 않기","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-01-17","slug":"/posts/til-kotlin-inline-reflection"},"frontmatter":{"title":"[TIL] 코틀린 inline, reflection","image":"https://velog.velcdn.com/images/aryumka/post/14ac2014-f469-4a23-b3cd-d95c2e912efe/image.png"}}},{"node":{"fields":{"date":"2024-01-24","slug":"/posts/query-if-null-return"},"frontmatter":{"title":"[TIL] 쿼리로 피벗 시 if 함수에서 의도된 Null 리턴","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-01-25","slug":"/posts/kotlin-reflection"},"frontmatter":{"title":"[JVM 톺아보기] 코틀린의 리플렉션(Reflection)","image":"https://velog.velcdn.com/images/aryumka/post/c9d716a4-0eef-4663-90e1-69631029d564/image.png"}}},{"node":{"fields":{"date":"2024-02-01","slug":"/posts/jvm-permgen"},"frontmatter":{"title":"[JVM 톺아보기] JVM의 메서드 영역 (feat. PermGen space)","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-02-06","slug":"/posts/real-mysql"},"frontmatter":{"title":"[TIL] Real MySQL","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-02-07","slug":"/posts/til-kotlin-sort"},"frontmatter":{"title":"[TIL] Kotlin - sortedWith과 compareBy를 이용한 다중조건 정렬","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-02-18","slug":"/posts/reinventing-di-framework"},"frontmatter":{"title":"[바퀴의 재발명] DI 프레임워크 직접 만들어보기","image":"https://velog.velcdn.com/images/aryumka/post/94394c32-2228-4acb-8be0-a82e13fa78a1/image.png"}}},{"node":{"fields":{"date":"2024-03-02","slug":"/posts/til-kotlin-jpa-test"},"frontmatter":{"title":"[TIL] Kotlin + JPA + Kotest + H2 DB","image":"https://velog.velcdn.com/images/aryumka/post/af776ead-b672-4d57-80bb-fe6fac180764/image.png"}}},{"node":{"fields":{"date":"2024-03-03","slug":"/posts/functional-exception"},"frontmatter":{"title":"[TIL] 예외를 함수로 처리","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-04-03","slug":"/posts/til-json"},"frontmatter":{"title":"[TIL] JSON 유효하지 않은 문자열 제거","image":"https://velog.velcdn.com/images/aryumka/post/ed5979e8-49ef-4be8-9a1c-5b9203d2574f/image.png"}}},{"node":{"fields":{"date":"2024-04-22","slug":"/posts/rabbitmq-seven-patterns"},"frontmatter":{"title":"RabbitMQ 7가지 설계 패턴 (with Spring AMQP tutorial)","image":"https://velog.velcdn.com/images/aryumka/post/f2266935-81ba-47b8-9b4f-910d28c1aaef/image.png"}}},{"node":{"fields":{"date":"2024-05-04","slug":"/posts/til-test-container"},"frontmatter":{"title":"[TIL] Test Container","image":"https://velog.velcdn.com/images/aryumka/post/9fcbd346-bd6e-4097-bce9-b7c9468b5cfc/image.png"}}},{"node":{"fields":{"date":"2024-05-05","slug":"/posts/til-axon-framework"},"frontmatter":{"title":"[TIL] Axon Framework - Token","image":"/images/og.png"}}}]}},"pageContext":{"slug":"/posts/reinventing-di-framework","series":{"title":"바퀴의 재발명","items":[{"title":"[바퀴의 재발명] BigInteger","url":"/posts/reinventing-big-integer"},{"title":"[바퀴의 재발명] DI 프레임워크 직접 만들어보기","url":"/posts/reinventing-di-framework"}]},"frontmatter":{"title":"[바퀴의 재발명] DI 프레임워크 직접 만들어보기","categories":"dev","tags":["Kotlin","DI"],"series":"바퀴의 재발명","cover":"","image":"https://velog.velcdn.com/images/aryumka/post/94394c32-2228-4acb-8be0-a82e13fa78a1/image.png","comments":true,"draft":false,"hide":false}}},"staticQueryHashes":["595849736","63159454"],"slicesMap":{}}