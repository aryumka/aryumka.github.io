{"componentChunkName":"component---src-templates-post-tsx-content-file-path-src-posts-2024-01-25-kotlin-reflection-mdx","path":"/posts/kotlin-reflection/","result":{"data":{"site":{"siteMetadata":{"title":"aryumka.me | devlog"}},"mdx":{"body":"\nimport Image from '@components/Image';\n\n## 리플렉션이란?\n런타임에 동적으로 클래스의 인스턴스를 **생성 및 조작**할 수 있는 기술이다. 리플렉션을 사용하면 클래스에 대한 정보를 미리 알지 못해도 객체를 조작할 수 있다.\n\n주로 프로그램 내 특정 클래스나 함수에 대해 알지 못하는 라이브러리나 프레임워크 등에서 런타임에 동적으로 객체를 생성, 조작, 참조할 때 사용된다 (일반적인 코드를 작성할 때는 이미 클래스들의 정보를 알고 있으므로 사용할 일이 거의 없다).\n대표적으로 스프링에서 빈을 생성, 주입할 때 리플렉션을 사용한다. \n\n## 리플렉션의 작동원리\n이게 어떻게 가능한걸까?\nJVM 기반 언어에서 리플렉션 API는 컴파일 후 런타임에 로드된 **JVM의 스태틱 영역(메서드 영역 또는 클래스 영역)에 접근**하여 일급시민들의 메타데이터를 조작하기 때문이다.\n\n따라서 클래스나 함수의 이름만 알고 있다면 클래스의 생성자, 메서드, 멤버와 속성들까지도 거의 무한에 가까운 자유도로 객체를 제어할 수 있다.\n\n예를 들어 아래와 같은 private 생성자를 가진 클래스를\n```kotlin\nclass Foo private constructor(private val name: String = \"Foo\"){\n    override fun toString(): String {\n        return \"Foo(name='$name')\"\n    }\n}\n```\n아래와 같이 접근성을 조작하여 직접 생성할 수도 있다.\n```kotlin\nfun main() {\n    val ctor = Foo::class.primaryConstructor\n    ctor?.isAccessible = true\n    val foo = ctor?.call(\"Bar\")\n    println(foo) //Foo(name='Bar')\n}\n```\n\n## 코틀린 리플렉션 API\n### gradle 의존성 추가\n코틀린은 자바 리플렉션 `java.lang.reflect`과 코틀린 리플렉션 `kotlin.reflect`의 두 가지 방식을 제공한다.\n자바에 존재하지 않는 nullable 타입이나 속성 등을 리플렉션하기 위해 아래와 같이 별도의 의존성을 추가해주어야 한다.\n```kotlin\n//gradle\ndependencies {\n    implementation(kotlin(\"reflect\"))\n}\n```\n코틀린의 리플렉션 API는 코틀린 뿐만이 아닌 다른 JVM 기반 언어들과 호환된다.\n### 리플렉션이 가능한 대상\n\n<Image src=\"https://velog.velcdn.com/images/aryumka/post/2352d0a0-9fa0-44c9-b037-acec8dcd887e/image.png\" />\n\n코틀린 리플렉션은 위와 같은 계층구조를 갖고 있다.\n클래스의 리플렉션인 `KClass`, 함수 `KFunction`와 변수`KProperty`, 그리고 이들을 포함하는 `KCallable`과 `KParameter`로 이루어져 있다\n\n\n#### 클래스\n```kotlin\nval c = MyClass::class\nprintln(c.simpleName) //클래스 이름 출력\nprintln(c.qualifiedName) //패키지 경로를 포함한 클래스 이름 출력\nval ctors = c.constructors //클래스의 생성자들을 모두 가져옴\nc.isSealed = false // sealed class인지 여부. 재할당 가능\n...\n```\n`::`를 사용하여 사용해 클래스를 참조하며 위의 예시 이외에도 참조된 클래스를 제어하는 방법이 [KClass API 문서](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/)에 자세히 설명되어 있다.\n#### 함수\n함수도 `::`를 활용하여 KFuntion으로 참조할 수 있다.\n```kotlin\nval f = ::foo()\nf.call(\"Hello\")\nf.callBy(mapOf(f.parameters[0] to \"Hello\"))\nf.isInline\nf.isExternal\nf.visibility\n```\n리플렉션으로 가져온 함수를 바로 인자로 넘겨줄 수도 있다.\n```kotlin\nfun isOdd(x: Int) = x % 2 != 0\nval numbers = listOf(1, 2, 3)\nprintln(numbers.filter(::isOdd))\n```\n생성자인 Constructor도 KFuntion타입이다. \n[KFunction API 문서](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-function/)\n### 인자\n함수의 인자인 `KParameter`도 리플렉션이 가능하다.\n```kotlin\nval param = MyClass::Class.primaryConstructor!!.parameters.firstOrNull()\nparam.name\nparam.type\nparam.isOptional\nparam.isVararg\nparam.index\nparam.annotations\n```\n[KParameter API 문서](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-parameter/)\n#### 변수\n변수도 위와 같이 제어가 가능하다. val로 선언된 변수도 수정이 가능하다.\n[KProperty API 문서](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-property/)\n## 주의할 점\n- 동적으로 생성되기 때문에 예측이 어렵다. 어떤 객체가 생성되며 어떤 메서드가 호출될 지. 따라서 컴파일타임과 런타임 시에 JVM 최적화가 어렵다. \n- 런타임에 조작된 속성은 실행 중 계속 유지된다. 따라서 accessibility등을 조작 시 보안 이슈가 발생할 수 있다.\n- 플랫폼 종속적이다. 리플렉션을 사용하여 만든 프로그램은 jvm 위에서만 동작한다. ","tableOfContents":{"items":[{"url":"#리플렉션이란","title":"리플렉션이란?"},{"url":"#리플렉션의-작동원리","title":"리플렉션의 작동원리"},{"url":"#코틀린-리플렉션-api","title":"코틀린 리플렉션 API","items":[{"url":"#gradle-의존성-추가","title":"gradle 의존성 추가"},{"url":"#리플렉션이-가능한-대상","title":"리플렉션이 가능한 대상","items":[{"url":"#클래스","title":"클래스"},{"url":"#함수","title":"함수"}]},{"url":"#인자","title":"인자","items":[{"url":"#변수","title":"변수"}]}]},{"url":"#주의할-점","title":"주의할 점"}]},"excerpt":"리플렉션이란? 런타임에 동적으로 클래스의 인스턴스를 생성 및 조작할 수 있는 기술이다. 리플렉션을 사용하면 클래스에 대한 정보를 미리 알지 못해도 객체를 조작할 수 있다.\n\n주로 프로그램 내 특정 클래스나 함수에 대해 알지 못하는 라이브러리나…","fields":{"slug":"/posts/kotlin-reflection","date":"2024-01-25"},"frontmatter":{"title":"[JVM 톺아보기] 코틀린의 리플렉션(Reflection)","categories":"dev","tags":["JVM","Kotlin","Reflection"],"image":"https://velog.velcdn.com/images/aryumka/post/c9d716a4-0eef-4663-90e1-69631029d564/image.png","comments":true,"draft":false}},"allMdx":{"edges":[{"node":{"fields":{"date":"2023-03-18","slug":"/posts/spring-boot-tomcat"},"frontmatter":{"title":"스프링부트의 톰캣 실행","image":"https://velog.velcdn.com/images/aryumka/post/5b95b704-67df-48b2-bdde-620b629f10ae/image.png"}}},{"node":{"fields":{"date":"2023-04-10","slug":"/posts/jsoup-html-parser"},"frontmatter":{"title":"Jsoup을 이용하여 HTML Parser 만들기","image":"https://velog.velcdn.com/images/aryumka/post/251571e0-9d24-4ef3-aa0d-f4d8654212c3/image.png"}}},{"node":{"fields":{"date":"2023-12-24","slug":"/posts/properties-vs-yaml"},"frontmatter":{"title":"Properties vs YAML - 스프링부트 외부설정","image":"https://velog.velcdn.com/images/aryumka/post/9173f985-e7b4-4d03-9996-93a08c517845/image.png"}}},{"node":{"fields":{"date":"2023-12-25","slug":"/posts/mysql-date-type"},"frontmatter":{"title":"MySQL date 타입에 대하여: varchar(8)과의 비교를 중점으로","image":"https://velog.velcdn.com/images/aryumka/post/e84fde44-1e6e-436e-bf62-6749c6ca1845/image.png"}}},{"node":{"fields":{"date":"2023-12-28","slug":"/posts/holiday-til-1"},"frontmatter":{"title":"[연휴개발TIL] DAY1 - kotiln + kotest + Spring Data JPA","image":"https://velog.velcdn.com/images/aryumka/post/9173f985-e7b4-4d03-9996-93a08c517845/image.png"}}},{"node":{"fields":{"date":"2023-12-29","slug":"/posts/holiday-til-2"},"frontmatter":{"title":"[연휴개발TIL] DAY2 - Github Action + Mockk","image":"https://velog.velcdn.com/images/aryumka/post/6e45e3ee-1592-433f-a0e8-e69b23738caf/image.png"}}},{"node":{"fields":{"date":"2023-12-31","slug":"/posts/holiday-til-3"},"frontmatter":{"title":"[연휴개발TIL] DAY3","image":"https://velog.velcdn.com/images/aryumka/post/0c169fc0-5d98-4cd2-9d50-04672ebc9d84/image.png"}}},{"node":{"fields":{"date":"2024-01-02","slug":"/posts/holiday-til-4"},"frontmatter":{"title":"[연휴개발TIL] DAY3","image":"https://velog.velcdn.com/images/aryumka/post/3e146a87-d66d-4ff3-953f-9da5e5c92441/image.png"}}},{"node":{"fields":{"date":"2024-01-03","slug":"/posts/github-actions"},"frontmatter":{"title":"GitHub Actions 정리","image":"https://velog.velcdn.com/images/aryumka/post/07ec2107-424c-4a8c-9c11-005508653ee2/image.png"}}},{"node":{"fields":{"date":"2024-01-04","slug":"/posts/til-aws-elastic-ip-docker"},"frontmatter":{"title":"[TIL] aws 탄력적 ip + Docker 사용해보기","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-01-07","slug":"/posts/til-practice-tdd"},"frontmatter":{"title":"[TIL] README, 테스트 작성과 코드 구현","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-01-09","slug":"/posts/til-kotlin-binary"},"frontmatter":{"title":"[TIL] 코틀린 이진수 변환","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-01-10","slug":"/posts/til-java-static-block-kotlin-companion-object"},"frontmatter":{"title":"[TIL] Java의 static block vs Kotlin의 companion object","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-01-14","slug":"/posts/reinventing-big-integer"},"frontmatter":{"title":"[바퀴의 재발명] BigInteger","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-01-15","slug":"/posts/til-resource"},"frontmatter":{"title":"[TIL] 리소스 위치 참조 시 / 쓰지 않기","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-01-16","slug":"/posts/til-gradle-build-error"},"frontmatter":{"title":"[TIL] 인텔리제이 gradle 빌드 오류(feat. JDK 버젼 호환)","image":"https://velog.velcdn.com/images/aryumka/post/14ac2014-f469-4a23-b3cd-d95c2e912efe/image.png"}}},{"node":{"fields":{"date":"2024-01-17","slug":"/posts/til-kotlin-inline-reflection"},"frontmatter":{"title":"[TIL] 코틀린 inline, reflection","image":"https://velog.velcdn.com/images/aryumka/post/14ac2014-f469-4a23-b3cd-d95c2e912efe/image.png"}}},{"node":{"fields":{"date":"2024-01-24","slug":"/posts/query-if-null-return"},"frontmatter":{"title":"[TIL] 쿼리로 피벗 시 if 함수에서 의도된 Null 리턴","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-01-25","slug":"/posts/kotlin-reflection"},"frontmatter":{"title":"[JVM 톺아보기] 코틀린의 리플렉션(Reflection)","image":"https://velog.velcdn.com/images/aryumka/post/c9d716a4-0eef-4663-90e1-69631029d564/image.png"}}},{"node":{"fields":{"date":"2024-02-01","slug":"/posts/jvm-permgen"},"frontmatter":{"title":"[JVM 톺아보기] JVM의 메서드 영역 (feat. PermGen space)","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-02-06","slug":"/posts/real-mysql"},"frontmatter":{"title":"[TIL] Real MySQL","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-02-07","slug":"/posts/til-kotlin-sort"},"frontmatter":{"title":"[TIL] Kotlin - sortedWith과 compareBy를 이용한 다중조건 정렬","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-02-18","slug":"/posts/reinventing-di-framework"},"frontmatter":{"title":"[바퀴의 재발명] DI 프레임워크 직접 만들어보기","image":"https://velog.velcdn.com/images/aryumka/post/94394c32-2228-4acb-8be0-a82e13fa78a1/image.png"}}},{"node":{"fields":{"date":"2024-03-02","slug":"/posts/til-kotlin-jpa-test"},"frontmatter":{"title":"[TIL] Kotlin + JPA + Kotest + H2 DB","image":"https://velog.velcdn.com/images/aryumka/post/af776ead-b672-4d57-80bb-fe6fac180764/image.png"}}},{"node":{"fields":{"date":"2024-03-03","slug":"/posts/functional-exception"},"frontmatter":{"title":"[TIL] 예외를 함수로 처리","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-04-22","slug":"/posts/rabbitmq-seven-patterns"},"frontmatter":{"title":"RabbitMQ 7가지 설계 패턴 (with Spring AMQP tutorial)","image":"https://velog.velcdn.com/images/aryumka/post/f2266935-81ba-47b8-9b4f-910d28c1aaef/image.png"}}},{"node":{"fields":{"date":"2024-04-03","slug":"/posts/til-json"},"frontmatter":{"title":"[TIL] JSON 유효하지 않은 문자열 제거","image":"https://velog.velcdn.com/images/aryumka/post/ed5979e8-49ef-4be8-9a1c-5b9203d2574f/image.png"}}},{"node":{"fields":{"date":"2024-05-04","slug":"/posts/til-test-container"},"frontmatter":{"title":"[TIL] Test Container","image":"https://velog.velcdn.com/images/aryumka/post/9fcbd346-bd6e-4097-bce9-b7c9468b5cfc/image.png"}}},{"node":{"fields":{"date":"2024-05-05","slug":"/posts/til-axon-framework"},"frontmatter":{"title":"[TIL] Axon Framework - Token","image":"/images/og.png"}}},{"node":{"fields":{"date":"2024-05-12","slug":"/posts/kafka-axon-eventsourcing"},"frontmatter":{"title":"Kafka와 Axon Framework를 이용한 이벤트 소싱 - 1","image":"/images/og.png"}}}]}},"pageContext":{"slug":"/posts/kotlin-reflection","series":{"title":"JVM 톺아보기","items":[{"title":"[JVM 톺아보기] 코틀린의 리플렉션(Reflection)","url":"/posts/kotlin-reflection"},{"title":"[JVM 톺아보기] JVM의 메서드 영역 (feat. PermGen space)","url":"/posts/jvm-permgen"}]},"frontmatter":{"title":"[JVM 톺아보기] 코틀린의 리플렉션(Reflection)","categories":"dev","tags":["JVM","Kotlin","Reflection"],"series":"JVM 톺아보기","cover":"","image":"https://velog.velcdn.com/images/aryumka/post/c9d716a4-0eef-4663-90e1-69631029d564/image.png","comments":true,"draft":false,"hide":false}}},"staticQueryHashes":["595849736","63159454"],"slicesMap":{}}